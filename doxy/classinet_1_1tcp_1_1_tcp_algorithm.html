<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INET Framework for OMNeT++/OMNEST: inet::tcp::TcpAlgorithm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="opp.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classinet_1_1tcp_1_1_tcp_algorithm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classinet_1_1tcp_1_1_tcp_algorithm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">inet::tcp::TcpAlgorithm Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for TCP algorithms which encapsulate all behaviour during data transfer state: flavour of congestion control, fast retransmit/recovery, selective acknowledgement etc.  
 <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#details">More...</a></p>

<p><code>#include &lt;TcpAlgorithm.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for inet::tcp::TcpAlgorithm:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classinet_1_1tcp_1_1_tcp_algorithm.png" usemap="#inet::tcp::TcpAlgorithm_map" alt=""/>
  <map id="inet::tcp::TcpAlgorithm_map" name="inet::tcp::TcpAlgorithm_map">
<area href="classinet_1_1tcp_1_1_dumb_tcp.html" title="A very-very basic TcpAlgorithm implementation, with hardcoded retransmission timeout and no other sop..." alt="inet::tcp::DumbTcp" shape="rect" coords="0,112,202,136"/>
<area href="classinet_1_1tcp_1_1_tcp_base_alg.html" title="Includes basic TCP algorithms: adaptive retransmission, PERSIST timer, keep-alive,..." alt="inet::tcp::TcpBaseAlg" shape="rect" coords="424,112,626,136"/>
<area href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html" title="TCP with no congestion control (i.e." alt="inet::tcp::TcpNoCongestionControl" shape="rect" coords="0,168,202,192"/>
<area href="classinet_1_1tcp_1_1_tcp_tahoe_reno_family.html" title="Provides utility functions to implement TcpTahoe, TcpReno and TcpNewReno." alt="inet::tcp::TcpTahoeRenoFamily" shape="rect" coords="318,168,520,192"/>
<area href="classinet_1_1tcp_1_1_tcp_vegas.html" alt="inet::tcp::TcpVegas" shape="rect" coords="530,168,732,192"/>
<area href="classinet_1_1tcp_1_1_tcp_westwood.html" alt="inet::tcp::TcpWestwood" shape="rect" coords="742,168,944,192"/>
<area href="classinet_1_1tcp_1_1_dc_tcp_family.html" title="Provides utility functions to implement DcTcp." alt="inet::tcp::DcTcpFamily" shape="rect" coords="0,224,202,248"/>
<area href="classinet_1_1tcp_1_1_tcp_new_reno.html" title="Implements TCP NewReno." alt="inet::tcp::TcpNewReno" shape="rect" coords="212,224,414,248"/>
<area href="classinet_1_1tcp_1_1_tcp_reno.html" title="Implements TCP Reno." alt="inet::tcp::TcpReno" shape="rect" coords="424,224,626,248"/>
<area href="classinet_1_1tcp_1_1_tcp_tahoe.html" title="Implements Tahoe." alt="inet::tcp::TcpTahoe" shape="rect" coords="636,224,838,248"/>
<area href="classinet_1_1tcp_1_1_dc_tcp.html" title="Implements DCTCP." alt="inet::tcp::DcTcp" shape="rect" coords="424,280,626,304"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac320200af64740095887b57a6c48b3a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ac320200af64740095887b57a6c48b3a8">TcpAlgorithm</a> ()</td></tr>
<tr class="memdesc:ac320200af64740095887b57a6c48b3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ac320200af64740095887b57a6c48b3a8">More...</a><br /></td></tr>
<tr class="separator:ac320200af64740095887b57a6c48b3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab132eb92b9163e49cfe49bc6a3f8a3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a2ab132eb92b9163e49cfe49bc6a3f8a3">~TcpAlgorithm</a> ()</td></tr>
<tr class="memdesc:a2ab132eb92b9163e49cfe49bc6a3f8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual dtor.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a2ab132eb92b9163e49cfe49bc6a3f8a3">More...</a><br /></td></tr>
<tr class="separator:a2ab132eb92b9163e49cfe49bc6a3f8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf782f289486e0b60a0e513971632b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#aaf782f289486e0b60a0e513971632b87">setConnection</a> (<a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html">TcpConnection</a> *_conn)</td></tr>
<tr class="memdesc:aaf782f289486e0b60a0e513971632b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this object to a <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html" title="Manages a TCP connection.">TcpConnection</a>.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#aaf782f289486e0b60a0e513971632b87">More...</a><br /></td></tr>
<tr class="separator:aaf782f289486e0b60a0e513971632b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45a513394fa38752737ea7e8caea65e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1tcp_1_1_tcp_state_variables.html">TcpStateVariables</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae45a513394fa38752737ea7e8caea65e">getStateVariables</a> ()</td></tr>
<tr class="memdesc:ae45a513394fa38752737ea7e8caea65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns the TCP state variables.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae45a513394fa38752737ea7e8caea65e">More...</a><br /></td></tr>
<tr class="separator:ae45a513394fa38752737ea7e8caea65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2b3d6a2cb7c47354493c67c144e0cf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a4c2b3d6a2cb7c47354493c67c144e0cf">initialize</a> ()</td></tr>
<tr class="memdesc:a4c2b3d6a2cb7c47354493c67c144e0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should be redefined to initialize the object: create timers, etc.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a4c2b3d6a2cb7c47354493c67c144e0cf">More...</a><br /></td></tr>
<tr class="separator:a4c2b3d6a2cb7c47354493c67c144e0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64ef9fd85c8ff6dd25d746dbf831e1c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#aa64ef9fd85c8ff6dd25d746dbf831e1c">established</a> (bool active)=0</td></tr>
<tr class="memdesc:aa64ef9fd85c8ff6dd25d746dbf831e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the connection is going to ESTABLISHED from SYN_SENT or SYN_RCVD.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#aa64ef9fd85c8ff6dd25d746dbf831e1c">More...</a><br /></td></tr>
<tr class="separator:aa64ef9fd85c8ff6dd25d746dbf831e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c522a4f856714ffaaaef933c731b149"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a1c522a4f856714ffaaaef933c731b149">connectionClosed</a> ()=0</td></tr>
<tr class="memdesc:a1c522a4f856714ffaaaef933c731b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the connection closes, it should cancel all running timers.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a1c522a4f856714ffaaaef933c731b149">More...</a><br /></td></tr>
<tr class="separator:a1c522a4f856714ffaaaef933c731b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5594138f315ab12573fac280ec05ed4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a5594138f315ab12573fac280ec05ed4e">processTimer</a> (cMessage *timer, <a class="el" href="namespaceinet_1_1tcp.html#a5968e29470e4155db503982ded1d33be">TcpEventCode</a> &amp;event)=0</td></tr>
<tr class="memdesc:a5594138f315ab12573fac280ec05ed4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place to process timers specific to this <a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html" title="Abstract base class for TCP algorithms which encapsulate all behaviour during data transfer state: fl...">TcpAlgorithm</a> class.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a5594138f315ab12573fac280ec05ed4e">More...</a><br /></td></tr>
<tr class="separator:a5594138f315ab12573fac280ec05ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337d6f4a64a013e7ad5fa24d60961c50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a337d6f4a64a013e7ad5fa24d60961c50">sendCommandInvoked</a> ()=0</td></tr>
<tr class="memdesc:a337d6f4a64a013e7ad5fa24d60961c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after user sent TCP_C_SEND command to us.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a337d6f4a64a013e7ad5fa24d60961c50">More...</a><br /></td></tr>
<tr class="separator:a337d6f4a64a013e7ad5fa24d60961c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37961d5bbfbf8fb75b90f08787bfc6be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a37961d5bbfbf8fb75b90f08787bfc6be">receivedOutOfOrderSegment</a> ()=0</td></tr>
<tr class="memdesc:a37961d5bbfbf8fb75b90f08787bfc6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after receiving data which are in the window, but not at its left edge (seq != rcv_nxt).  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a37961d5bbfbf8fb75b90f08787bfc6be">More...</a><br /></td></tr>
<tr class="separator:a37961d5bbfbf8fb75b90f08787bfc6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba883a97661105f6f6d6d77e15758fe9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#aba883a97661105f6f6d6d77e15758fe9">receiveSeqChanged</a> ()=0</td></tr>
<tr class="memdesc:aba883a97661105f6f6d6d77e15758fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after rcv_nxt got advanced, either because we received in-sequence data ("text" in RFC 793 lingo) or a FIN.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#aba883a97661105f6f6d6d77e15758fe9">More...</a><br /></td></tr>
<tr class="separator:aba883a97661105f6f6d6d77e15758fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d716ea52ca02eed748706f10b595b58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a9d716ea52ca02eed748706f10b595b58">receivedDataAck</a> (uint32_t firstSeqAcked)=0</td></tr>
<tr class="memdesc:a9d716ea52ca02eed748706f10b595b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after we received an ACK which acked some data (that is, we could advance snd_una).  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a9d716ea52ca02eed748706f10b595b58">More...</a><br /></td></tr>
<tr class="separator:a9d716ea52ca02eed748706f10b595b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10b0c0c2dbc3e7ba77f5c6fcda74e0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae10b0c0c2dbc3e7ba77f5c6fcda74e0d">receivedDuplicateAck</a> ()=0</td></tr>
<tr class="memdesc:ae10b0c0c2dbc3e7ba77f5c6fcda74e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after we received a duplicate ACK (that is: ackNo == snd_una, no data in segment, segment doesn't carry window update, and also, we have unacked data).  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae10b0c0c2dbc3e7ba77f5c6fcda74e0d">More...</a><br /></td></tr>
<tr class="separator:ae10b0c0c2dbc3e7ba77f5c6fcda74e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac839f5fc37c9808122c5772036019a85"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ac839f5fc37c9808122c5772036019a85">receivedAckForDataNotYetSent</a> (uint32_t seq)=0</td></tr>
<tr class="memdesc:ac839f5fc37c9808122c5772036019a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after we received an ACK for data not yet sent.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ac839f5fc37c9808122c5772036019a85">More...</a><br /></td></tr>
<tr class="separator:ac839f5fc37c9808122c5772036019a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1292ff172208a4aaacc2475f0a24ca6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ad1292ff172208a4aaacc2475f0a24ca6">ackSent</a> ()=0</td></tr>
<tr class="memdesc:ad1292ff172208a4aaacc2475f0a24ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after we sent an ACK.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ad1292ff172208a4aaacc2475f0a24ca6">More...</a><br /></td></tr>
<tr class="separator:ad1292ff172208a4aaacc2475f0a24ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82e69467fe1056d434778c37fcb149d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae82e69467fe1056d434778c37fcb149d">dataSent</a> (uint32_t fromseq)=0</td></tr>
<tr class="memdesc:ae82e69467fe1056d434778c37fcb149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after we sent data.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae82e69467fe1056d434778c37fcb149d">More...</a><br /></td></tr>
<tr class="separator:ae82e69467fe1056d434778c37fcb149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad965cbba967109e9cae36a41ec46e2cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ad965cbba967109e9cae36a41ec46e2cc">segmentRetransmitted</a> (uint32_t fromseq, uint32_t toseq)=0</td></tr>
<tr class="memdesc:ad965cbba967109e9cae36a41ec46e2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after we retransmitted segment.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ad965cbba967109e9cae36a41ec46e2cc">More...</a><br /></td></tr>
<tr class="separator:ad965cbba967109e9cae36a41ec46e2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc5345bfd2869217e526a1b42a983d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a3cc5345bfd2869217e526a1b42a983d1">restartRexmitTimer</a> ()=0</td></tr>
<tr class="memdesc:a3cc5345bfd2869217e526a1b42a983d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart REXMIT timer.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a3cc5345bfd2869217e526a1b42a983d1">More...</a><br /></td></tr>
<tr class="separator:a3cc5345bfd2869217e526a1b42a983d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5411009fe0168685672cebf801292d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ad5411009fe0168685672cebf801292d1">rttMeasurementCompleteUsingTS</a> (uint32_t echoedTS)=0</td></tr>
<tr class="memdesc:ad5411009fe0168685672cebf801292d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting uint32_t echoedTS to simtime_t and calling rttMeasurementComplete() to update state vars with new measured RTT value.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ad5411009fe0168685672cebf801292d1">More...</a><br /></td></tr>
<tr class="separator:ad5411009fe0168685672cebf801292d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b544cc8ab57b7d381371b0d1cc671f4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a0b544cc8ab57b7d381371b0d1cc671f4">shouldMarkAck</a> ()=0</td></tr>
<tr class="memdesc:a0b544cc8ab57b7d381371b0d1cc671f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before sending ACK.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a0b544cc8ab57b7d381371b0d1cc671f4">More...</a><br /></td></tr>
<tr class="separator:a0b544cc8ab57b7d381371b0d1cc671f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860eafb2dc4a15a272ed31807b09043"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae860eafb2dc4a15a272ed31807b09043">processEcnInEstablished</a> ()=0</td></tr>
<tr class="memdesc:ae860eafb2dc4a15a272ed31807b09043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before processing segment in established state.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#ae860eafb2dc4a15a272ed31807b09043">More...</a><br /></td></tr>
<tr class="separator:ae860eafb2dc4a15a272ed31807b09043"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaf98b08619b50bf06bb949d67f0c1512"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classinet_1_1tcp_1_1_tcp_state_variables.html">TcpStateVariables</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#aaf98b08619b50bf06bb949d67f0c1512">createStateVariables</a> ()=0</td></tr>
<tr class="memdesc:aaf98b08619b50bf06bb949d67f0c1512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create state block (TCB) used by this TCP variant.  <a href="classinet_1_1tcp_1_1_tcp_algorithm.html#aaf98b08619b50bf06bb949d67f0c1512">More...</a><br /></td></tr>
<tr class="separator:aaf98b08619b50bf06bb949d67f0c1512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7b057c0eaae7752c77899bcd24cda588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html">TcpConnection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a7b057c0eaae7752c77899bcd24cda588">conn</a></td></tr>
<tr class="separator:a7b057c0eaae7752c77899bcd24cda588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82f62ac3190a35c6466cba745504591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1tcp_1_1_tcp_state_variables.html">TcpStateVariables</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html#af82f62ac3190a35c6466cba745504591">state</a></td></tr>
<tr class="separator:af82f62ac3190a35c6466cba745504591"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for TCP algorithms which encapsulate all behaviour during data transfer state: flavour of congestion control, fast retransmit/recovery, selective acknowledgement etc. </p>
<p>Subclasses may implement various sets and flavours of the above algorithms. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac320200af64740095887b57a6c48b3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac320200af64740095887b57a6c48b3a8">&#9670;&nbsp;</a></span>TcpAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inet::tcp::TcpAlgorithm::TcpAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor. </p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;{ <a class="code" href="classinet_1_1tcp_1_1_tcp_algorithm.html#af82f62ac3190a35c6466cba745504591">state</a> = <span class="keyword">nullptr</span>; <a class="code" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a7b057c0eaae7752c77899bcd24cda588">conn</a> = <span class="keyword">nullptr</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ab132eb92b9163e49cfe49bc6a3f8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab132eb92b9163e49cfe49bc6a3f8a3">&#9670;&nbsp;</a></span>~TcpAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual inet::tcp::TcpAlgorithm::~TcpAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual dtor. </p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad1292ff172208a4aaacc2475f0a24ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1292ff172208a4aaacc2475f0a24ca6">&#9670;&nbsp;</a></span>ackSent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::ackSent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after we sent an ACK. </p>
<p>This hook can be used to cancel the delayed-ACK timer. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a8727d4740e20022ae578867f71300096">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a067cc863c3aa9b5de1d6a58f5ed8b07a">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a93c2dec9ae82329e76fa37c0bf6ea730">inet::tcp::TcpConnection::retransmitOneSegment()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#ac16044dfebbb178c5941ab62380b8601">inet::tcp::TcpConnection::sendAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a2d63bfdd2c222e3898a922e1cd35c117">inet::tcp::TcpConnection::sendData()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#ab2c6979d1519488109b9a8fc029081a2">inet::tcp::TcpConnection::sendFin()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#ac98e6eb26dabef91260e4ea36e70ccbd">inet::tcp::TcpConnection::sendOneNewSegment()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a53293619e77207f0f2efb029da9ea37c">inet::tcp::TcpConnection::sendProbe()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a247e7362ec8ea0956d44f5c97aeffa24">inet::tcp::TcpConnection::sendRstAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#acc4b52c9e9becab1674bdbf2e7b4164e">inet::tcp::TcpConnection::sendSegmentDuringLossRecoveryPhase()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a69abf2064bebb5deaf8169d034cfca86">inet::tcp::TcpConnection::sendSynAck()</a>.</p>

</div>
</div>
<a id="a1c522a4f856714ffaaaef933c731b149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c522a4f856714ffaaaef933c731b149">&#9670;&nbsp;</a></span>connectionClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::connectionClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the connection closes, it should cancel all running timers. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a6f179a4833ac2bb6e6b0addb0501b6f9">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#aeb3ee1b23ac761f188529b18e972c2dc">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a759a1d53d5b30d2a1f5f14bb76bf55a4">inet::tcp::TcpConnection::stateEntered()</a>.</p>

</div>
</div>
<a id="aaf98b08619b50bf06bb949d67f0c1512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf98b08619b50bf06bb949d67f0c1512">&#9670;&nbsp;</a></span>createStateVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classinet_1_1tcp_1_1_tcp_state_variables.html">TcpStateVariables</a>* inet::tcp::TcpAlgorithm::createStateVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create state block (TCB) used by this TCP variant. </p>
<p>It is expected that every <a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html" title="Abstract base class for TCP algorithms which encapsulate all behaviour during data transfer state: fl...">TcpAlgorithm</a> subclass will have its own state block, subclassed from <a class="el" href="classinet_1_1tcp_1_1_tcp_state_variables.html" title="Contains state variables (&quot;TCB&quot;) for TCP.">TcpStateVariables</a>. This factory method should create and return a "blank" state block of the appropriate type. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#aa78532d0bab43057953fa23942751572">inet::tcp::TcpVegas</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#a164883ca543540c2a70f8593350bc751">inet::tcp::TcpWestwood</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a0a99ee741e1f1638d5bec0f98a093ae9">inet::tcp::DumbTcp</a>, <a class="el" href="classinet_1_1tcp_1_1_dc_tcp.html#a831f8f92c7476f12fcdb11d5521653bb">inet::tcp::DcTcp</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html#ac7b3374600be7574504f5e3144e22783">inet::tcp::TcpNoCongestionControl</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe.html#a76d0d1a9a4294bee7e42ff87d34eaab8">inet::tcp::TcpTahoe</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_reno.html#a1ff0e93d1444d45ff6f6f25c95651cc0">inet::tcp::TcpReno</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_new_reno.html#a5e977850fdf83aeb6021e03f71f75cdf">inet::tcp::TcpNewReno</a>.</p>

</div>
</div>
<a id="ae82e69467fe1056d434778c37fcb149d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82e69467fe1056d434778c37fcb149d">&#9670;&nbsp;</a></span>dataSent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::dataSent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fromseq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after we sent data. </p>
<p>This hook can be used to schedule the retransmission timer, to start round-trip time measurement, etc. The argument is the seqno of the first byte sent. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#aef5f1ef6e90b0950e672be22bad07d1c">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#a83d5726d5eb7d9a77791b1d9fd83f8ab">inet::tcp::TcpVegas</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#acadcc468be6a2e2ed4abea8dc9850261">inet::tcp::DumbTcp</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#aaa98a596c962d0fecfd6470e9d53fc1e">inet::tcp::TcpWestwood</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a2d63bfdd2c222e3898a922e1cd35c117">inet::tcp::TcpConnection::sendData()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#ac98e6eb26dabef91260e4ea36e70ccbd">inet::tcp::TcpConnection::sendOneNewSegment()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a53293619e77207f0f2efb029da9ea37c">inet::tcp::TcpConnection::sendProbe()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#acc4b52c9e9becab1674bdbf2e7b4164e">inet::tcp::TcpConnection::sendSegmentDuringLossRecoveryPhase()</a>.</p>

</div>
</div>
<a id="aa64ef9fd85c8ff6dd25d746dbf831e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64ef9fd85c8ff6dd25d746dbf831e1c">&#9670;&nbsp;</a></span>established()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::established </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the connection is going to ESTABLISHED from SYN_SENT or SYN_RCVD. </p>
<p>This is a place to initialize some variables (e.g. set cwnd to the MSS learned during connection setup). If we are on the active side, here we also have to finish the 3-way connection setup procedure by sending an ACK, possibly piggybacked on data. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#ae5930c4a285c2002be1e21a3c48279db">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a5912db08ae7e25154e8692c5e3740c40">inet::tcp::DumbTcp</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html#a1781d6406347ba4ccba72a9ce254c374">inet::tcp::TcpNoCongestionControl</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a89fb3bba962a1f9b37c4139066fd5851">inet::tcp::TcpConnection::processSegment1stThru8th()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a729b16908c898a0ccf73af5c736f1ee2">inet::tcp::TcpConnection::processSegmentInSynSent()</a>.</p>

</div>
</div>
<a id="ae45a513394fa38752737ea7e8caea65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45a513394fa38752737ea7e8caea65e">&#9670;&nbsp;</a></span>getStateVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1tcp_1_1_tcp_state_variables.html">TcpStateVariables</a>* inet::tcp::TcpAlgorithm::getStateVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns the TCP state variables. </p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classinet_1_1tcp_1_1_tcp_algorithm.html#af82f62ac3190a35c6466cba745504591">state</a>)</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            <a class="code" href="classinet_1_1tcp_1_1_tcp_algorithm.html#af82f62ac3190a35c6466cba745504591">state</a> = <a class="code" href="classinet_1_1tcp_1_1_tcp_algorithm.html#aaf98b08619b50bf06bb949d67f0c1512">createStateVariables</a>();</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classinet_1_1tcp_1_1_tcp_algorithm.html#af82f62ac3190a35c6466cba745504591">state</a>;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a19a634fbbac40c82d92c32505d377132">inet::tcp::TcpConnection::initClonedConnection()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a559d4b4984ef8f4957dba6d2ee2002dc">inet::tcp::TcpConnection::initConnection()</a>.</p>

</div>
</div>
<a id="a4c2b3d6a2cb7c47354493c67c144e0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2b3d6a2cb7c47354493c67c144e0cf">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should be redefined to initialize the object: create timers, etc. </p>
<p>This method is necessary because the <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html" title="Manages a TCP connection.">TcpConnection</a> ptr is not available in the constructor yet. </p>

<p>Reimplemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a03fa6f1a5f085b4fad770565eadb517a">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a84b7a176fe2b33fdcb0da573258957e3">inet::tcp::DumbTcp</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html#a7ad3a027e723c0731337aacfa8fb8e82">inet::tcp::TcpNoCongestionControl</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe_reno_family.html#a7bc74d28f18c9a67b67b2a0e11a8597c">inet::tcp::TcpTahoeRenoFamily</a>, and <a class="el" href="classinet_1_1tcp_1_1_dc_tcp.html#ab3ac8b348e6617fad61ba347cbe490e2">inet::tcp::DcTcp</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;{}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a19a634fbbac40c82d92c32505d377132">inet::tcp::TcpConnection::initClonedConnection()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a559d4b4984ef8f4957dba6d2ee2002dc">inet::tcp::TcpConnection::initConnection()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a84b7a176fe2b33fdcb0da573258957e3">inet::tcp::DumbTcp::initialize()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a03fa6f1a5f085b4fad770565eadb517a">inet::tcp::TcpBaseAlg::initialize()</a>.</p>

</div>
</div>
<a id="ae860eafb2dc4a15a272ed31807b09043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae860eafb2dc4a15a272ed31807b09043">&#9670;&nbsp;</a></span>processEcnInEstablished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::processEcnInEstablished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before processing segment in established state. </p>
<p>This function process ECN marks. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a5d0e6166a0439b654decbc47348c48ef">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#ae29cee93e8eadd20dd02eb05902f1e00">inet::tcp::DumbTcp</a>, and <a class="el" href="classinet_1_1tcp_1_1_dc_tcp.html#a503a94c4b8576976c756c3209d8df69b">inet::tcp::DcTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a89fb3bba962a1f9b37c4139066fd5851">inet::tcp::TcpConnection::processSegment1stThru8th()</a>.</p>

</div>
</div>
<a id="a5594138f315ab12573fac280ec05ed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5594138f315ab12573fac280ec05ed4e">&#9670;&nbsp;</a></span>processTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::processTimer </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinet_1_1tcp.html#a5968e29470e4155db503982ded1d33be">TcpEventCode</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place to process timers specific to this <a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html" title="Abstract base class for TCP algorithms which encapsulate all behaviour during data transfer state: fl...">TcpAlgorithm</a> class. </p>
<p><a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html" title="Manages a TCP connection.">TcpConnection</a> will invoke this method on any timer (self-message) it doesn't recognize (that is, any timer other than the 2MSL, CONN-ESTAB and FIN-WAIT-2 timers).</p>
<p>Method may also change the event code (by default set to TCP_E_IGNORE) to cause the state transition of TCP FSM. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a0c0d872e3634f42d962810515d2be3dd">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#ae24ba59481726ae1a1f8095e8827a933">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#aa41b2cd9b54a275b28246d319ba690d7">inet::tcp::TcpConnection::processTimer()</a>.</p>

</div>
</div>
<a id="ac839f5fc37c9808122c5772036019a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac839f5fc37c9808122c5772036019a85">&#9670;&nbsp;</a></span>receivedAckForDataNotYetSent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::receivedAckForDataNotYetSent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after we received an ACK for data not yet sent. </p>
<p>According to RFC 793 this function should send an ACK. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a43171b0fb2785d56b9023c7762fd7876">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a1adcafe3c78ea8c2e0de84f5825c5e61">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a1e61db9d8578ff50bec8d72fe818aa5f">inet::tcp::TcpConnection::processAckInEstabEtc()</a>.</p>

</div>
</div>
<a id="a9d716ea52ca02eed748706f10b595b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d716ea52ca02eed748706f10b595b58">&#9670;&nbsp;</a></span>receivedDataAck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::receivedDataAck </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstSeqAcked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after we received an ACK which acked some data (that is, we could advance snd_una). </p>
<p>At this point the state variables (snd_una, snd_wnd) have already been updated. The argument firstSeqAcked is the previous snd_una value, that is, the number of bytes acked is (snd_una - firstSeqAcked). The dupack counter still reflects the old value (needed for Reno and NewReno); it'll be reset to 0 after this call returns. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#adf81dcd693c796f18426ac903b4f6e92">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#acba422a674c37292b9bfa0e6d97e82c1">inet::tcp::TcpVegas</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#af25d111ac5ddfa0d2d79712c6bc3c482">inet::tcp::DumbTcp</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#a3f04bf68448f7acb8998b5d0032d63f7">inet::tcp::TcpWestwood</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html#ae5cf5406ae11425988ec74e1a96f6692">inet::tcp::TcpNoCongestionControl</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe.html#a49b1191882429188a60ab7d36cdf1baa">inet::tcp::TcpTahoe</a>, <a class="el" href="classinet_1_1tcp_1_1_dc_tcp.html#a516faa96e43e4eba49a59d9be7343821">inet::tcp::DcTcp</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_reno.html#a4313b7777b967f944719f5b10aa814ec">inet::tcp::TcpReno</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_new_reno.html#acba41bec364e407e4ef19573a68ecf91">inet::tcp::TcpNewReno</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a1e61db9d8578ff50bec8d72fe818aa5f">inet::tcp::TcpConnection::processAckInEstabEtc()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a89fb3bba962a1f9b37c4139066fd5851">inet::tcp::TcpConnection::processSegment1stThru8th()</a>.</p>

</div>
</div>
<a id="ae10b0c0c2dbc3e7ba77f5c6fcda74e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10b0c0c2dbc3e7ba77f5c6fcda74e0d">&#9670;&nbsp;</a></span>receivedDuplicateAck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::receivedDuplicateAck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after we received a duplicate ACK (that is: ackNo == snd_una, no data in segment, segment doesn't carry window update, and also, we have unacked data). </p>
<p>The dupack counter got already updated when calling this method (i.e. dupacks == 1 on first duplicate ACK.) </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a1e126b4d3699f8c67f80395d51d57d10">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#a833292b3780019267a62f7102ff2dbd6">inet::tcp::TcpVegas</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#ac622658e1b52c4f0e3656e5123061c2f">inet::tcp::TcpWestwood</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#af5b40fac5687abd8d515f8a568b234bd">inet::tcp::DumbTcp</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe.html#a6649c5bca8f060d2f672e413385998eb">inet::tcp::TcpTahoe</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_reno.html#a10c49fdf579139304be902761a0baff4">inet::tcp::TcpReno</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_new_reno.html#a038b3c89b3aaeba16d5d94f9ece9b0d7">inet::tcp::TcpNewReno</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a1e61db9d8578ff50bec8d72fe818aa5f">inet::tcp::TcpConnection::processAckInEstabEtc()</a>.</p>

</div>
</div>
<a id="a37961d5bbfbf8fb75b90f08787bfc6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37961d5bbfbf8fb75b90f08787bfc6be">&#9670;&nbsp;</a></span>receivedOutOfOrderSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::receivedOutOfOrderSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after receiving data which are in the window, but not at its left edge (seq != rcv_nxt). </p>
<p>This indicates that either segments got re-ordered in the way, or one segment was lost. RFC 1122 and RFC 2001 recommend sending an immediate ACK here (Fast Retransmit relies on that). </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#aefb3433bab6210cf6b443e692ff3d280">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a48040438393883c3ac3269545705f371">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a89fb3bba962a1f9b37c4139066fd5851">inet::tcp::TcpConnection::processSegment1stThru8th()</a>.</p>

</div>
</div>
<a id="aba883a97661105f6f6d6d77e15758fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba883a97661105f6f6d6d77e15758fe9">&#9670;&nbsp;</a></span>receiveSeqChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::receiveSeqChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after rcv_nxt got advanced, either because we received in-sequence data ("text" in RFC 793 lingo) or a FIN. </p>
<p>At this point, rcv_nxt has already been updated. This method should take care to send or schedule an ACK some time. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a17261f406f13d6e0c77f9a2f42bd42de">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#ae342639398c2f496a68b7cba5af3b3b6">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a89fb3bba962a1f9b37c4139066fd5851">inet::tcp::TcpConnection::processSegment1stThru8th()</a>.</p>

</div>
</div>
<a id="a3cc5345bfd2869217e526a1b42a983d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc5345bfd2869217e526a1b42a983d1">&#9670;&nbsp;</a></span>restartRexmitTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::restartRexmitTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart REXMIT timer. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a626d1a1ccbf499b99dfccd7078d694c1">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a32e0fcd23a96ac0584bf987e4932ac62">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#ac9a8e7dbde1f4102cec960e9566af010">inet::tcp::TcpConnection::process_CLOSE()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a2d63bfdd2c222e3898a922e1cd35c117">inet::tcp::TcpConnection::sendData()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#acc4b52c9e9becab1674bdbf2e7b4164e">inet::tcp::TcpConnection::sendSegmentDuringLossRecoveryPhase()</a>.</p>

</div>
</div>
<a id="ad5411009fe0168685672cebf801292d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5411009fe0168685672cebf801292d1">&#9670;&nbsp;</a></span>rttMeasurementCompleteUsingTS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::rttMeasurementCompleteUsingTS </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>echoedTS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting uint32_t echoedTS to simtime_t and calling rttMeasurementComplete() to update state vars with new measured RTT value. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a87699cc8f9580a8d5e64922e67df4942">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#aa08d8bb65e0fff6e1cd232587c3066f1">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a1e61db9d8578ff50bec8d72fe818aa5f">inet::tcp::TcpConnection::processAckInEstabEtc()</a>.</p>

</div>
</div>
<a id="ad965cbba967109e9cae36a41ec46e2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad965cbba967109e9cae36a41ec46e2cc">&#9670;&nbsp;</a></span>segmentRetransmitted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::segmentRetransmitted </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fromseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>toseq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after we retransmitted segment. </p>
<p>The argument fromseq is the seqno of the first byte sent. The argument toseq is the seqno of the last byte sent+1. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a182ad2adfd3b3631c5208d8365e2c324">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#a30ae26feb03c1caf636c4262bcda5ebf">inet::tcp::TcpVegas</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#aa9b8ccbd1bffcad6fe570db067eed924">inet::tcp::DumbTcp</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#a877805c6b6d70938fbdae2f6e0dddad8">inet::tcp::TcpWestwood</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a69d92cf8b5ea339a828b34b33fc102a3">inet::tcp::TcpConnection::retransmitData()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a93c2dec9ae82329e76fa37c0bf6ea730">inet::tcp::TcpConnection::retransmitOneSegment()</a>.</p>

</div>
</div>
<a id="a337d6f4a64a013e7ad5fa24d60961c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337d6f4a64a013e7ad5fa24d60961c50">&#9670;&nbsp;</a></span>sendCommandInvoked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inet::tcp::TcpAlgorithm::sendCommandInvoked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after user sent TCP_C_SEND command to us. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a7cce206a01795af39b5401597aaead2f">inet::tcp::TcpBaseAlg</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#abeb15e53d4d4bba73d2328d10087c065">inet::tcp::DumbTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#ab7160020102c9f27f6c1e3b1698ee5ac">inet::tcp::TcpConnection::process_SEND()</a>.</p>

</div>
</div>
<a id="aaf782f289486e0b60a0e513971632b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf782f289486e0b60a0e513971632b87">&#9670;&nbsp;</a></span>setConnection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::tcp::TcpAlgorithm::setConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html">TcpConnection</a> *&#160;</td>
          <td class="paramname"><em>_conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign this object to a <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html" title="Manages a TCP connection.">TcpConnection</a>. </p>
<p>Its sendQueue and receiveQueue must be set already at this time, because we cache their pointers here. </p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;{ <a class="code" href="classinet_1_1tcp_1_1_tcp_algorithm.html#a7b057c0eaae7752c77899bcd24cda588">conn</a> = _conn; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a19a634fbbac40c82d92c32505d377132">inet::tcp::TcpConnection::initClonedConnection()</a>, and <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#a559d4b4984ef8f4957dba6d2ee2002dc">inet::tcp::TcpConnection::initConnection()</a>.</p>

</div>
</div>
<a id="a0b544cc8ab57b7d381371b0d1cc671f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b544cc8ab57b7d381371b0d1cc671f4">&#9670;&nbsp;</a></span>shouldMarkAck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool inet::tcp::TcpAlgorithm::shouldMarkAck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before sending ACK. </p>
<p>Determines whether to set ECE bit. </p>

<p>Implemented in <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a67ec6a013903550760a9374f37affb5d">inet::tcp::TcpBaseAlg</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#ae092c8e18c390a21c7a37199b7118f49">inet::tcp::DumbTcp</a>, and <a class="el" href="classinet_1_1tcp_1_1_dc_tcp.html#ab889ccd78b504a03093a08a3c037f94f">inet::tcp::DcTcp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html#ac16044dfebbb178c5941ab62380b8601">inet::tcp::TcpConnection::sendAck()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7b057c0eaae7752c77899bcd24cda588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b057c0eaae7752c77899bcd24cda588">&#9670;&nbsp;</a></span>conn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1tcp_1_1_tcp_connection.html">TcpConnection</a>* inet::tcp::TcpAlgorithm::conn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#aeb3ee1b23ac761f188529b18e972c2dc">inet::tcp::DumbTcp::connectionClosed()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#acadcc468be6a2e2ed4abea8dc9850261">inet::tcp::DumbTcp::dataSent()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html#a1781d6406347ba4ccba72a9ce254c374">inet::tcp::TcpNoCongestionControl::established()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a5912db08ae7e25154e8692c5e3740c40">inet::tcp::DumbTcp::established()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#ae5930c4a285c2002be1e21a3c48279db">inet::tcp::TcpBaseAlg::established()</a>, <a class="el" href="classinet_1_1tcp_1_1_dc_tcp.html#ab3ac8b348e6617fad61ba347cbe490e2">inet::tcp::DcTcp::initialize()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe_reno_family.html#a7bc74d28f18c9a67b67b2a0e11a8597c">inet::tcp::TcpTahoeRenoFamily::initialize()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a84b7a176fe2b33fdcb0da573258957e3">inet::tcp::DumbTcp::initialize()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a03fa6f1a5f085b4fad770565eadb517a">inet::tcp::TcpBaseAlg::initialize()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a3b7478d0b5d0667781842f6db2d4f1d3">inet::tcp::TcpBaseAlg::processDelayedAckTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#af0cf5f64a1e7705c0f086c7d7cdfad2d">inet::tcp::TcpBaseAlg::processPersistTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html#a6ca3ac5e608890ee7db49ce43ecc7151">inet::tcp::TcpNoCongestionControl::processRexmitTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_new_reno.html#a916479f2e29e5c82e445be8df80ca8e5">inet::tcp::TcpNewReno::processRexmitTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_reno.html#ab39ea09946a36c19863df21de5ae4d90">inet::tcp::TcpReno::processRexmitTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe.html#ab1a3634d3dd4dab57033b66f6f30c274">inet::tcp::TcpTahoe::processRexmitTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#a0fbe32b26f2b9025461957c03f88d531">inet::tcp::TcpWestwood::processRexmitTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#ad50709a4b6a09d6c0ba55cdfe56abe2e">inet::tcp::TcpVegas::processRexmitTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a1ff5c2c9d5fa9cc0139e05e6c4b87c18">inet::tcp::TcpBaseAlg::processRexmitTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#ae24ba59481726ae1a1f8095e8827a933">inet::tcp::DumbTcp::processTimer()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_new_reno.html#a9f407fa1e9610dd7fb58fbb65d7a7b21">inet::tcp::TcpNewReno::recalculateSlowStartThreshold()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_reno.html#a548ad1f1bf03b6001a11537e8dc08f8a">inet::tcp::TcpReno::recalculateSlowStartThreshold()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe.html#a65923147025507a99902e19829b1a813">inet::tcp::TcpTahoe::recalculateSlowStartThreshold()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#a1ce5d68d621543ff215ee11cb80530bf">inet::tcp::TcpWestwood::recalculateSlowStartThreshold()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#abf2dae9c346b5aca215e6beda5ef96f0">inet::tcp::TcpVegas::recalculateSlowStartThreshold()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a1adcafe3c78ea8c2e0de84f5825c5e61">inet::tcp::DumbTcp::receivedAckForDataNotYetSent()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a43171b0fb2785d56b9023c7762fd7876">inet::tcp::TcpBaseAlg::receivedAckForDataNotYetSent()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_new_reno.html#acba41bec364e407e4ef19573a68ecf91">inet::tcp::TcpNewReno::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_dc_tcp.html#a516faa96e43e4eba49a59d9be7343821">inet::tcp::DcTcp::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_reno.html#a4313b7777b967f944719f5b10aa814ec">inet::tcp::TcpReno::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe.html#a49b1191882429188a60ab7d36cdf1baa">inet::tcp::TcpTahoe::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#a3f04bf68448f7acb8998b5d0032d63f7">inet::tcp::TcpWestwood::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#af25d111ac5ddfa0d2d79712c6bc3c482">inet::tcp::DumbTcp::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#acba422a674c37292b9bfa0e6d97e82c1">inet::tcp::TcpVegas::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#adf81dcd693c796f18426ac903b4f6e92">inet::tcp::TcpBaseAlg::receivedDataAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_new_reno.html#a038b3c89b3aaeba16d5d94f9ece9b0d7">inet::tcp::TcpNewReno::receivedDuplicateAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_reno.html#a10c49fdf579139304be902761a0baff4">inet::tcp::TcpReno::receivedDuplicateAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_tahoe.html#a6649c5bca8f060d2f672e413385998eb">inet::tcp::TcpTahoe::receivedDuplicateAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_westwood.html#ac622658e1b52c4f0e3656e5123061c2f">inet::tcp::TcpWestwood::receivedDuplicateAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_vegas.html#a833292b3780019267a62f7102ff2dbd6">inet::tcp::TcpVegas::receivedDuplicateAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a1e126b4d3699f8c67f80395d51d57d10">inet::tcp::TcpBaseAlg::receivedDuplicateAck()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#a48040438393883c3ac3269545705f371">inet::tcp::DumbTcp::receivedOutOfOrderSegment()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#aefb3433bab6210cf6b443e692ff3d280">inet::tcp::TcpBaseAlg::receivedOutOfOrderSegment()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#ae342639398c2f496a68b7cba5af3b3b6">inet::tcp::DumbTcp::receiveSeqChanged()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a17261f406f13d6e0c77f9a2f42bd42de">inet::tcp::TcpBaseAlg::receiveSeqChanged()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a8853d776fc36f8cc28353879681964b7">inet::tcp::TcpBaseAlg::rttMeasurementComplete()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a87699cc8f9580a8d5e64922e67df4942">inet::tcp::TcpBaseAlg::rttMeasurementCompleteUsingTS()</a>, <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#abeb15e53d4d4bba73d2328d10087c065">inet::tcp::DumbTcp::sendCommandInvoked()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_no_congestion_control.html#a9590dde8899c347507f6ad39f9aa31bc">inet::tcp::TcpNoCongestionControl::sendData()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#a7e9461014cb424632888252758ba114a">inet::tcp::TcpBaseAlg::sendData()</a>, <a class="el" href="classinet_1_1tcp_1_1_tcp_base_alg.html#ade47a4258550278898619120bee0a4a8">inet::tcp::TcpBaseAlg::startRexmitTimer()</a>, and <a class="el" href="classinet_1_1tcp_1_1_dumb_tcp.html#afb777e83970e0482d3e1a9bd5e24825f">inet::tcp::DumbTcp::~DumbTcp()</a>.</p>

</div>
</div>
<a id="af82f62ac3190a35c6466cba745504591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82f62ac3190a35c6466cba745504591">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1tcp_1_1_tcp_state_variables.html">TcpStateVariables</a>* inet::tcp::TcpAlgorithm::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_tcp_algorithm_8h.html">TcpAlgorithm.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassinet_1_1tcp_1_1_tcp_algorithm_html_aaf98b08619b50bf06bb949d67f0c1512"><div class="ttname"><a href="classinet_1_1tcp_1_1_tcp_algorithm.html#aaf98b08619b50bf06bb949d67f0c1512">inet::tcp::TcpAlgorithm::createStateVariables</a></div><div class="ttdeci">virtual TcpStateVariables * createStateVariables()=0</div><div class="ttdoc">Create state block (TCB) used by this TCP variant.</div></div>
<div class="ttc" id="aclassinet_1_1tcp_1_1_tcp_algorithm_html_a7b057c0eaae7752c77899bcd24cda588"><div class="ttname"><a href="classinet_1_1tcp_1_1_tcp_algorithm.html#a7b057c0eaae7752c77899bcd24cda588">inet::tcp::TcpAlgorithm::conn</a></div><div class="ttdeci">TcpConnection * conn</div><div class="ttdef"><b>Definition:</b> TcpAlgorithm.h:26</div></div>
<div class="ttc" id="aclassinet_1_1tcp_1_1_tcp_algorithm_html_af82f62ac3190a35c6466cba745504591"><div class="ttname"><a href="classinet_1_1tcp_1_1_tcp_algorithm.html#af82f62ac3190a35c6466cba745504591">inet::tcp::TcpAlgorithm::state</a></div><div class="ttdeci">TcpStateVariables * state</div><div class="ttdef"><b>Definition:</b> TcpAlgorithm.h:27</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinet.html">inet</a></li><li class="navelem"><a class="el" href="namespaceinet_1_1tcp.html">tcp</a></li><li class="navelem"><a class="el" href="classinet_1_1tcp_1_1_tcp_algorithm.html">TcpAlgorithm</a></li>
    <li class="footer">Generated on Sun Apr 10 2022 21:00:43 for INET Framework for OMNeT++/OMNEST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
