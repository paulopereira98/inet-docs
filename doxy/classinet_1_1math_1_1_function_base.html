<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INET Framework for OMNeT++/OMNEST: inet::math::FunctionBase&lt; R, D &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="opp.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classinet_1_1math_1_1_function_base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classinet_1_1math_1_1_function_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">inet::math::FunctionBase&lt; R, D &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Useful base class for most <a class="el" href="classinet_1_1math_1_1_i_function.html" title="This interface represents a mathematical function from domain D to range R.">IFunction</a> implementations with some default behavior.  
 <a href="classinet_1_1math_1_1_function_base.html#details">More...</a></p>

<p><code>#include &lt;FunctionBase.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for inet::math::FunctionBase&lt; R, D &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classinet_1_1math_1_1_function_base.png" usemap="#inet::math::FunctionBase_3C_20R_2C_20D_20_3E_map" alt=""/>
  <map id="inet::math::FunctionBase_3C_20R_2C_20D_20_3E_map" name="inet::math::FunctionBase_3C_20R_2C_20D_20_3E_map">
<area href="classinet_1_1math_1_1_i_function.html" title="This interface represents a mathematical function from domain D to range R." alt="inet::math::IFunction&lt; R, D &gt;" shape="rect" coords="191,56,564,80"/>
<area href="classinet_1_1math_1_1_added_function.html" alt="inet::math::AddedFunction&lt; R, D &gt;" shape="rect" coords="574,168,947,192"/>
<area href="classinet_1_1math_1_1_approximated_function.html" title="Approximates the values and partitioning of a multidimensional function along one of the dimensions." alt="inet::math::ApproximatedFunction&lt; R, D, DIMENSION, X &gt;" shape="rect" coords="574,224,947,248"/>
<area href="classinet_1_1math_1_1_bilinear_function.html" title="Linear in two dimensions and constant in the others." alt="inet::math::BilinearFunction&lt; R, D &gt;" shape="rect" coords="574,280,947,304"/>
<area href="classinet_1_1math_1_1_constant_function.html" alt="inet::math::ConstantFunction&lt; R, D &gt;" shape="rect" coords="574,336,947,360"/>
<area href="classinet_1_1math_1_1_domain_limited_function.html" title="Limits the domain of a multidimensional function." alt="inet::math::DomainLimitedFunction&lt; R, D &gt;" shape="rect" coords="574,392,947,416"/>
<area href="classinet_1_1math_1_1_domain_shifted_function.html" title="Shifts the domain of a multidimensional function." alt="inet::math::DomainShiftedFunction&lt; R, D &gt;" shape="rect" coords="574,448,947,472"/>
<area href="classinet_1_1math_1_1_left_currying_function.html" title="Fixes the parameters of a function from the left." alt="inet::math::LeftCurryingFunction&lt; R, C, DIMSC, D, DIMSD, E &gt;" shape="rect" coords="574,504,947,528"/>
<area href="classinet_1_1math_1_1_memoized_function.html" title="Truncates the values of a multidimensional function outside the given domain to 0." alt="inet::math::MemoizedFunction&lt; R, D &gt;" shape="rect" coords="574,560,947,584"/>
<area href="classinet_1_1math_1_1_multiplied_function.html" alt="inet::math::MultipliedFunction&lt; R, D &gt;" shape="rect" coords="574,616,947,640"/>
<area href="classinet_1_1math_1_1_subtracted_function.html" alt="inet::math::SubtractedFunction&lt; R, D &gt;" shape="rect" coords="574,672,947,696"/>
<area href="classinet_1_1math_1_1_summed_function.html" alt="inet::math::SummedFunction&lt; R, D &gt;" shape="rect" coords="574,728,947,752"/>
<area href="classinet_1_1math_1_1_unilinear_function.html" title="Linear in one dimension and constant in the others." alt="inet::math::UnilinearFunction&lt; R, D &gt;" shape="rect" coords="574,784,947,808"/>
<area href="classinet_1_1math_1_1_unireciprocal_function.html" title="Reciprocal in a given dimension and constant in the others." alt="inet::math::UnireciprocalFunction&lt; R, D &gt;" shape="rect" coords="574,840,947,864"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a870ff025affae7dbdfb0a7779236ef81"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">partition</a> (const typename D::I &amp;i, const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt; callback) const override</td></tr>
<tr class="memdesc:a870ff025affae7dbdfb0a7779236ef81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivides the provided domain and calls back f with the subdomains and the corresponding potentially simpler domain limited functions.  <a href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">More...</a><br /></td></tr>
<tr class="separator:a870ff025affae7dbdfb0a7779236ef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68adbce26e59b9d984f0afabbe8fd7fc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a68adbce26e59b9d984f0afabbe8fd7fc">getRange</a> () const override</td></tr>
<tr class="memdesc:a68adbce26e59b9d984f0afabbe8fd7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the valid range of the function as an interval.  <a href="classinet_1_1math_1_1_function_base.html#a68adbce26e59b9d984f0afabbe8fd7fc">More...</a><br /></td></tr>
<tr class="separator:a68adbce26e59b9d984f0afabbe8fd7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72409d7985acd1d287531650d77bb027"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a72409d7985acd1d287531650d77bb027">getRange</a> (const typename D::I &amp;i) const override</td></tr>
<tr class="memdesc:a72409d7985acd1d287531650d77bb027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the valid range of the function as an interval for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#a72409d7985acd1d287531650d77bb027">More...</a><br /></td></tr>
<tr class="separator:a72409d7985acd1d287531650d77bb027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd3772c21c16e4a455a7f70fcae853"><td class="memItemLeft" align="right" valign="top">virtual D::I&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a> () const override</td></tr>
<tr class="memdesc:a3cfd3772c21c16e4a455a7f70fcae853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the valid domain of the function as an interval.  <a href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">More...</a><br /></td></tr>
<tr class="separator:a3cfd3772c21c16e4a455a7f70fcae853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11ddb62b77a40cd993fbeb44a3d1e3a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#ab11ddb62b77a40cd993fbeb44a3d1e3a">isFinite</a> () const override</td></tr>
<tr class="memdesc:ab11ddb62b77a40cd993fbeb44a3d1e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function value is finite in the whole domain.  <a href="classinet_1_1math_1_1_function_base.html#ab11ddb62b77a40cd993fbeb44a3d1e3a">More...</a><br /></td></tr>
<tr class="separator:ab11ddb62b77a40cd993fbeb44a3d1e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d1b6ae0cd7529e985dc9dc825cf043"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#ae3d1b6ae0cd7529e985dc9dc825cf043">isFinite</a> (const typename D::I &amp;i) const override</td></tr>
<tr class="memdesc:ae3d1b6ae0cd7529e985dc9dc825cf043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function value is finite in the given domain.  <a href="classinet_1_1math_1_1_function_base.html#ae3d1b6ae0cd7529e985dc9dc825cf043">More...</a><br /></td></tr>
<tr class="separator:ae3d1b6ae0cd7529e985dc9dc825cf043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dbb8539628f4168b390fcb3f78e09d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#af8dbb8539628f4168b390fcb3f78e09d">isNonZero</a> () const override</td></tr>
<tr class="memdesc:af8dbb8539628f4168b390fcb3f78e09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function value is non-zero in the whole domain.  <a href="classinet_1_1math_1_1_function_base.html#af8dbb8539628f4168b390fcb3f78e09d">More...</a><br /></td></tr>
<tr class="separator:af8dbb8539628f4168b390fcb3f78e09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fe35794f33ef8a8b1ccf126c1807c3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a43fe35794f33ef8a8b1ccf126c1807c3">isNonZero</a> (const typename D::I &amp;i) const override</td></tr>
<tr class="memdesc:a43fe35794f33ef8a8b1ccf126c1807c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function value is non-zero in the given domain.  <a href="classinet_1_1math_1_1_function_base.html#a43fe35794f33ef8a8b1ccf126c1807c3">More...</a><br /></td></tr>
<tr class="separator:a43fe35794f33ef8a8b1ccf126c1807c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36290a0acac3c7521e59b91e1ed0cda7"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a36290a0acac3c7521e59b91e1ed0cda7">getMin</a> () const override</td></tr>
<tr class="memdesc:a36290a0acac3c7521e59b91e1ed0cda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum value for the whole domain.  <a href="classinet_1_1math_1_1_function_base.html#a36290a0acac3c7521e59b91e1ed0cda7">More...</a><br /></td></tr>
<tr class="separator:a36290a0acac3c7521e59b91e1ed0cda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b19c1130b3e7e918318fd042c71790"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#ad5b19c1130b3e7e918318fd042c71790">getMin</a> (const typename D::I &amp;i) const override</td></tr>
<tr class="memdesc:ad5b19c1130b3e7e918318fd042c71790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum value for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#ad5b19c1130b3e7e918318fd042c71790">More...</a><br /></td></tr>
<tr class="separator:ad5b19c1130b3e7e918318fd042c71790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8ccec5b93a214efd528e120a7b5718"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#afe8ccec5b93a214efd528e120a7b5718">getMax</a> () const override</td></tr>
<tr class="memdesc:afe8ccec5b93a214efd528e120a7b5718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value for the whole domain.  <a href="classinet_1_1math_1_1_function_base.html#afe8ccec5b93a214efd528e120a7b5718">More...</a><br /></td></tr>
<tr class="separator:afe8ccec5b93a214efd528e120a7b5718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d2637a37dd5b70030eb9bbb95d6edf"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#aa0d2637a37dd5b70030eb9bbb95d6edf">getMax</a> (const typename D::I &amp;i) const override</td></tr>
<tr class="memdesc:aa0d2637a37dd5b70030eb9bbb95d6edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#aa0d2637a37dd5b70030eb9bbb95d6edf">More...</a><br /></td></tr>
<tr class="separator:aa0d2637a37dd5b70030eb9bbb95d6edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844360abf304a795038a86bdcc08a495"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a844360abf304a795038a86bdcc08a495">getMean</a> () const override</td></tr>
<tr class="memdesc:a844360abf304a795038a86bdcc08a495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean value for the whole domain.  <a href="classinet_1_1math_1_1_function_base.html#a844360abf304a795038a86bdcc08a495">More...</a><br /></td></tr>
<tr class="separator:a844360abf304a795038a86bdcc08a495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5325a884cb8bf59d340042d9e13ce7"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#afa5325a884cb8bf59d340042d9e13ce7">getMean</a> (const typename D::I &amp;i) const override</td></tr>
<tr class="memdesc:afa5325a884cb8bf59d340042d9e13ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean value for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#afa5325a884cb8bf59d340042d9e13ce7">More...</a><br /></td></tr>
<tr class="separator:afa5325a884cb8bf59d340042d9e13ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777b60ead65629ce5fc96b2f05338dc9"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a777b60ead65629ce5fc96b2f05338dc9">getIntegral</a> () const override</td></tr>
<tr class="memdesc:a777b60ead65629ce5fc96b2f05338dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integral value for the whole domain.  <a href="classinet_1_1math_1_1_function_base.html#a777b60ead65629ce5fc96b2f05338dc9">More...</a><br /></td></tr>
<tr class="separator:a777b60ead65629ce5fc96b2f05338dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12e92698e0c1ee33f72d74ccef9f5e3"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#ad12e92698e0c1ee33f72d74ccef9f5e3">getIntegral</a> (const typename D::I &amp;i) const override</td></tr>
<tr class="memdesc:ad12e92698e0c1ee33f72d74ccef9f5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integral value for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#ad12e92698e0c1ee33f72d74ccef9f5e3">More...</a><br /></td></tr>
<tr class="separator:ad12e92698e0c1ee33f72d74ccef9f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88894e0e77bfce4e5867e549d7bb6e44"><td class="memItemLeft" align="right" valign="top">virtual const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a88894e0e77bfce4e5867e549d7bb6e44">add</a> (const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;o) const override</td></tr>
<tr class="memdesc:a88894e0e77bfce4e5867e549d7bb6e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the provided function to this function.  <a href="classinet_1_1math_1_1_function_base.html#a88894e0e77bfce4e5867e549d7bb6e44">More...</a><br /></td></tr>
<tr class="separator:a88894e0e77bfce4e5867e549d7bb6e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ff3af06f9ab3b6dfd8d5409146dea"><td class="memItemLeft" align="right" valign="top">virtual const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a7c2ff3af06f9ab3b6dfd8d5409146dea">subtract</a> (const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;o) const override</td></tr>
<tr class="memdesc:a7c2ff3af06f9ab3b6dfd8d5409146dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts the provided function from this function.  <a href="classinet_1_1math_1_1_function_base.html#a7c2ff3af06f9ab3b6dfd8d5409146dea">More...</a><br /></td></tr>
<tr class="separator:a7c2ff3af06f9ab3b6dfd8d5409146dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1285ba8afd8c62fac7b5c122092531"><td class="memItemLeft" align="right" valign="top">virtual const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#abc1285ba8afd8c62fac7b5c122092531">multiply</a> (const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; double, D &gt;&gt; &amp;o) const override</td></tr>
<tr class="memdesc:abc1285ba8afd8c62fac7b5c122092531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the provided function with this function.  <a href="classinet_1_1math_1_1_function_base.html#abc1285ba8afd8c62fac7b5c122092531">More...</a><br /></td></tr>
<tr class="separator:abc1285ba8afd8c62fac7b5c122092531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefafc4ee64f38a557af69a8cdbb1bafb"><td class="memItemLeft" align="right" valign="top">virtual const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; double, D &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#aefafc4ee64f38a557af69a8cdbb1bafb">divide</a> (const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;o) const override</td></tr>
<tr class="memdesc:aefafc4ee64f38a557af69a8cdbb1bafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this function with the provided function.  <a href="classinet_1_1math_1_1_function_base.html#aefafc4ee64f38a557af69a8cdbb1bafb">More...</a><br /></td></tr>
<tr class="separator:aefafc4ee64f38a557af69a8cdbb1bafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b5fb58460be34844ef971372120286"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a92b5fb58460be34844ef971372120286">printOn</a> (std::ostream &amp;os) const override</td></tr>
<tr class="separator:a92b5fb58460be34844ef971372120286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb72fc50f58410e87b192e9ab2a2914"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a7bb72fc50f58410e87b192e9ab2a2914">print</a> (std::ostream &amp;os, int level=0) const override</td></tr>
<tr class="memdesc:a7bb72fc50f58410e87b192e9ab2a2914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints this function in human readable form to the provided stream for the whole domain.  <a href="classinet_1_1math_1_1_function_base.html#a7bb72fc50f58410e87b192e9ab2a2914">More...</a><br /></td></tr>
<tr class="separator:a7bb72fc50f58410e87b192e9ab2a2914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1badb187e7b1e32e0377c2c4f35cb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a3b1badb187e7b1e32e0377c2c4f35cb4">print</a> (std::ostream &amp;os, const typename D::I &amp;i, int level=0) const override</td></tr>
<tr class="memdesc:a3b1badb187e7b1e32e0377c2c4f35cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints this function in a human readable form to the provided stream for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#a3b1badb187e7b1e32e0377c2c4f35cb4">More...</a><br /></td></tr>
<tr class="separator:a3b1badb187e7b1e32e0377c2c4f35cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c986f9ac17ad81a15da3089c04b4e21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a6c986f9ac17ad81a15da3089c04b4e21">printPartitioning</a> (std::ostream &amp;os, const typename D::I &amp;i, int level) const override</td></tr>
<tr class="memdesc:a6c986f9ac17ad81a15da3089c04b4e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the partitioning of this function in a human readable form to the provided stream for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#a6c986f9ac17ad81a15da3089c04b4e21">More...</a><br /></td></tr>
<tr class="separator:a6c986f9ac17ad81a15da3089c04b4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186d11b46c8fb589798f9319b14fad48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#a186d11b46c8fb589798f9319b14fad48">printPartition</a> (std::ostream &amp;os, const typename D::I &amp;i, int level=0) const override</td></tr>
<tr class="memdesc:a186d11b46c8fb589798f9319b14fad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a single partition of this function in a human readable form to the provided stream for the given domain.  <a href="classinet_1_1math_1_1_function_base.html#a186d11b46c8fb589798f9319b14fad48">More...</a><br /></td></tr>
<tr class="separator:a186d11b46c8fb589798f9319b14fad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fbb2e03f24d4964ab9a06155ef0438"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html#ac1fbb2e03f24d4964ab9a06155ef0438">printStructure</a> (std::ostream &amp;os, int level=0) const override</td></tr>
<tr class="memdesc:ac1fbb2e03f24d4964ab9a06155ef0438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the internal data structure of this function in a human readable form to the provided stream.  <a href="classinet_1_1math_1_1_function_base.html#ac1fbb2e03f24d4964ab9a06155ef0438">More...</a><br /></td></tr>
<tr class="separator:ac1fbb2e03f24d4964ab9a06155ef0438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classinet_1_1math_1_1_i_function"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classinet_1_1math_1_1_i_function')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classinet_1_1math_1_1_i_function.html">inet::math::IFunction&lt; R, D &gt;</a></td></tr>
<tr class="memitem:a0580d64844a8f292eddcbe6683c48d55 inherit pub_methods_classinet_1_1math_1_1_i_function"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_i_function.html#a0580d64844a8f292eddcbe6683c48d55">~IFunction</a> ()</td></tr>
<tr class="separator:a0580d64844a8f292eddcbe6683c48d55 inherit pub_methods_classinet_1_1math_1_1_i_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b27bdf6c6459b2af0211dea54a9c18 inherit pub_methods_classinet_1_1math_1_1_i_function"><td class="memItemLeft" align="right" valign="top">virtual R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_i_function.html#a77b27bdf6c6459b2af0211dea54a9c18">getValue</a> (const typename D::P &amp;p) const =0</td></tr>
<tr class="memdesc:a77b27bdf6c6459b2af0211dea54a9c18 inherit pub_methods_classinet_1_1math_1_1_i_function"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the function at the given point.  <a href="classinet_1_1math_1_1_i_function.html#a77b27bdf6c6459b2af0211dea54a9c18">More...</a><br /></td></tr>
<tr class="separator:a77b27bdf6c6459b2af0211dea54a9c18 inherit pub_methods_classinet_1_1math_1_1_i_function"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename R, typename D&gt;<br />
class inet::math::FunctionBase&lt; R, D &gt;</h3>

<p>Useful base class for most <a class="el" href="classinet_1_1math_1_1_i_function.html" title="This interface represents a mathematical function from domain D to range R.">IFunction</a> implementations with some default behavior. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a88894e0e77bfce4e5867e549d7bb6e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88894e0e77bfce4e5867e549d7bb6e44">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Ptr&lt;const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt;R, D&gt; &gt; <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the provided function to this function. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#af4bc8308f3b3c273f23ba1c5a6d891eb">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">return</span> makeShared&lt;AddedFunction&lt;R, D&gt;&gt;(<span class="keyword">const_cast&lt;</span>FunctionBase&lt;R, D&gt; *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;shared_from_this(), o);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aefafc4ee64f38a557af69a8cdbb1bafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefafc4ee64f38a557af69a8cdbb1bafb">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Ptr&lt;const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt;double, D&gt; &gt; <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::divide </td>
          <td>(</td>
          <td class="paramtype">const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this function with the provided function. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a654e168c6b3abc5bca231cd1cc969f48">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                                                                                                             {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">return</span> makeShared&lt;DividedFunction&lt;R, D&gt;&gt;(<span class="keyword">const_cast&lt;</span>FunctionBase&lt;R, D&gt; *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;shared_from_this(), o);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3cfd3772c21c16e4a455a7f70fcae853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfd3772c21c16e4a455a7f70fcae853">&#9670;&nbsp;</a></span>getDomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual D::I <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the valid domain of the function as an interval. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#afe3ad410dcc3df3be1cf742675a1f919">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_summed_function.html#a440c4d4fb4e569f4bd0235a161fa15c8">inet::math::SummedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_multiplied_function.html#aed6bd4673033d16d3f5efd82cae5097e">inet::math::MultipliedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_subtracted_function.html#a254cdf462be85d655717e22918214eaa">inet::math::SubtractedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_shifted_function.html#aa629a0d68b417bbd1600aa5d7da5f5bd">inet::math::DomainShiftedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#ac491627e1d867edffacd3d4d23d6ddd3">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_added_function.html#a12be2d4835844d0c0b62c074d2be3ddc">inet::math::AddedFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                                   {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">typename</span> D::I(D::P::getLowerBounds(), D::P::getUpperBounds(), 0b0, 0b0, 0b0);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a777b60ead65629ce5fc96b2f05338dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777b60ead65629ce5fc96b2f05338dc9">&#9670;&nbsp;</a></span>getIntegral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getIntegral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integral value for the whole domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a5203b21dc7d9e94526c73e434f9675b9">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#a777b60ead65629ce5fc96b2f05338dc9">getIntegral</a>(<a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>()); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_function_base.html#a777b60ead65629ce5fc96b2f05338dc9">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::getIntegral()</a>.</p>

</div>
</div>
<a id="ad12e92698e0c1ee33f72d74ccef9f5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12e92698e0c1ee33f72d74ccef9f5e3">&#9670;&nbsp;</a></span>getIntegral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getIntegral </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integral value for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a77fb4abd4945c60ce9ea40a716b7e933">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#ae73c47c263d8df29338a11ee5c837805">inet::math::UnireciprocalFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#a9a56d9c3f3bdfc9bbdeeefc344116c39">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#ae79a089b16c91fd39f9dfc8a54bb3f49">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                                                               {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <a class="code" href="namespaceinet_1_1units_1_1constants.html#a1a7f5aced244de22a80826323f4f127a">R</a> result(0);</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        this-&gt;<a class="code" href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">partition</a>(i, [&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> D::I&amp; i1, <span class="keyword">const</span> IFunction&lt;R, D&gt; *f1) {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="keywordtype">double</span> volume = i1.getVolume();</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            <a class="code" href="namespaceinet_1_1units_1_1constants.html#a1a7f5aced244de22a80826323f4f127a">R</a> value = f1-&gt;getMean(i1);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="keywordflow">if</span> (!(value == <a class="code" href="namespaceinet_1_1units_1_1constants.html#a1a7f5aced244de22a80826323f4f127a">R</a>(0) &amp;&amp; std::isinf(volume)))</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                result += volume * value;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        });</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afe8ccec5b93a214efd528e120a7b5718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8ccec5b93a214efd528e120a7b5718">&#9670;&nbsp;</a></span>getMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum value for the whole domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#ac3941b1d94198e36683ac36f3324db4c">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#afe8ccec5b93a214efd528e120a7b5718">getMax</a>(<a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>()); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_function_base.html#afe8ccec5b93a214efd528e120a7b5718">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::getMax()</a>.</p>

</div>
</div>
<a id="aa0d2637a37dd5b70030eb9bbb95d6edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d2637a37dd5b70030eb9bbb95d6edf">&#9670;&nbsp;</a></span>getMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getMax </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum value for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a1e986a538b4e5c1a11a532250cfcec40">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#abfebdfd74561e069282b064335473c55">inet::math::UnireciprocalFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#a00d12876b561bbfcfe951e80fdd080e3">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a61e1180dd46ffc1ecdcb65a22ab3ef7b">inet::math::UnilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#aac14a77806f121e64f58bf5c50230247">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#aafbf9b589748cb9c715271438be47888">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                                                          {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <a class="code" href="namespaceinet_1_1units_1_1constants.html#a1a7f5aced244de22a80826323f4f127a">R</a> result(getLowerBound&lt;R&gt;());</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        this-&gt;<a class="code" href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">partition</a>(i, [&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> D::I&amp; i1, <span class="keyword">const</span> IFunction&lt;R, D&gt; *f1) {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            result = <a class="code" href="namespaceinet_1_1math.html#aadcb04b0e7b6f04876f0cadbdb37d7e9">math::maxnan</a>(f1-&gt;getMax(i1), result);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        });</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a844360abf304a795038a86bdcc08a495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844360abf304a795038a86bdcc08a495">&#9670;&nbsp;</a></span>getMean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getMean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mean value for the whole domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a877e19387584221debb94b11f43e9406">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#a844360abf304a795038a86bdcc08a495">getMean</a>(<a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>()); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_function_base.html#a844360abf304a795038a86bdcc08a495">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::getMean()</a>.</p>

</div>
</div>
<a id="afa5325a884cb8bf59d340042d9e13ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5325a884cb8bf59d340042d9e13ce7">&#9670;&nbsp;</a></span>getMean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getMean </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mean value for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a7d3761ebe5e3c04cc0576037afb1ac72">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#ab1def9c4c8f31ac73460ede38d8447d9">inet::math::UnireciprocalFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#ae9e5bfda54c98bd69b248ea0c7bf4809">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a2ed31dab87325019033949d9e0c0d88c">inet::math::UnilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#a6f4252e38ed941c8e513e241e004348c">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#a856280405bc522e15c45a965a135a1f4">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                                                           {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#a777b60ead65629ce5fc96b2f05338dc9">getIntegral</a>(i) / i.getVolume();</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a36290a0acac3c7521e59b91e1ed0cda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36290a0acac3c7521e59b91e1ed0cda7">&#9670;&nbsp;</a></span>getMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum value for the whole domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#ab4846bb8b4a5afc828ae8207a2dfbf3e">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#a36290a0acac3c7521e59b91e1ed0cda7">getMin</a>(<a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>()); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_function_base.html#a36290a0acac3c7521e59b91e1ed0cda7">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::getMin()</a>.</p>

</div>
</div>
<a id="ad5b19c1130b3e7e918318fd042c71790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b19c1130b3e7e918318fd042c71790">&#9670;&nbsp;</a></span>getMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual R <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getMin </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum value for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a580121895f962b54b97d88cb4b8e8526">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#a70403a41beddf7ac1a4902306cb054e9">inet::math::UnireciprocalFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#ab1e868f66b628fdacf226a42f9800094">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a7390408ce9e6b60b71df47b03ae954cb">inet::math::UnilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#a318a5d85a23b6173306fbd2502003694">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#aeb5d67dec624f33cd0c398a564cf78a2">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                                                          {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <a class="code" href="namespaceinet_1_1units_1_1constants.html#a1a7f5aced244de22a80826323f4f127a">R</a> result(getUpperBound&lt;R&gt;());</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        this-&gt;<a class="code" href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">partition</a>(i, [&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> D::I&amp; i1, <span class="keyword">const</span> IFunction&lt;R, D&gt; *f1) {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            result = <a class="code" href="namespaceinet_1_1math.html#ab05f5f363b17f9e2cc464f2d812a6295">math::minnan</a>(f1-&gt;getMin(i1), result);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        });</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a68adbce26e59b9d984f0afabbe8fd7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68adbce26e59b9d984f0afabbe8fd7fc">&#9670;&nbsp;</a></span>getRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt;R&gt; <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the valid range of the function as an interval. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a8959094d708b70934a2535ce4d5fc933">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#a5341d01e361136008b4ff80fda0c7758">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a67e1c67741061c48f1863f6a1a50ae8b">inet::math::UnilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#abfda107cc4f7d0a543c0af685ae4aef6">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#a0d7c24f8d410325f7b810fc1b97cc2b7">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                                                  {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#a68adbce26e59b9d984f0afabbe8fd7fc">getRange</a>(<a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>());</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a72409d7985acd1d287531650d77bb027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72409d7985acd1d287531650d77bb027">&#9670;&nbsp;</a></span>getRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt;R&gt; <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::getRange </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the valid range of the function as an interval for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#af9258996d104815693ac27b34c641458">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                                                                      {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">return</span> Interval&lt;R&gt;(getLowerBound&lt;R&gt;(), getUpperBound&lt;R&gt;(), 0b1, 0b1, 0b0);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab11ddb62b77a40cd993fbeb44a3d1e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11ddb62b77a40cd993fbeb44a3d1e3a">&#9670;&nbsp;</a></span>isFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::isFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the function value is finite in the whole domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#abc01a0040436dab6764d155993c7b868">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#ab11ddb62b77a40cd993fbeb44a3d1e3a">isFinite</a>(<a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>()); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_function_base.html#ab11ddb62b77a40cd993fbeb44a3d1e3a">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::isFinite()</a>.</p>

</div>
</div>
<a id="ae3d1b6ae0cd7529e985dc9dc825cf043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d1b6ae0cd7529e985dc9dc825cf043">&#9670;&nbsp;</a></span>isFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::isFinite </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the function value is finite in the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a99307aaf017e097b65d25bed75cde3a5">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_approximated_function.html#a0c9089b0ecc76ba91cbbadb94aec055c">inet::math::ApproximatedFunction&lt; R, D, DIMENSION, X &gt;</a>, <a class="el" href="classinet_1_1math_1_1_summed_function.html#a34e4cd35e33a46dcfbf2e8bb5c435c7a">inet::math::SummedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_divided_function.html#ac36438026d182bdaa3265db9ecb49565">inet::math::DividedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_multiplied_function.html#a4cc37f8869e6ff966ec4a91b9fb08415">inet::math::MultipliedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#aaf6bdb190de51a19f054b9aeb5f4a437">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_subtracted_function.html#af1d1b9bd6e003f8cef8c1286b1d7940e">inet::math::SubtractedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_added_function.html#a44be0890f5d318b1a5932ea3db978042">inet::math::AddedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a8d0f653c7128c196cce3a38b5647d8b0">inet::math::UnilinearFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#acf5682b71ad4507a4e3936309783dc83">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                                                               {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        this-&gt;<a class="code" href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">partition</a>(i, [&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> D::I&amp; i1, <span class="keyword">const</span> IFunction&lt;R, D&gt; *f1) {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            result &amp;= f1-&gt;isFinite(i1);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        });</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8dbb8539628f4168b390fcb3f78e09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8dbb8539628f4168b390fcb3f78e09d">&#9670;&nbsp;</a></span>isNonZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::isNonZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the function value is non-zero in the whole domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#ac96f21ff84ae58c422de7305f0c17238">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classinet_1_1math_1_1_function_base.html#af8dbb8539628f4168b390fcb3f78e09d">isNonZero</a>(<a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>()); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_function_base.html#af8dbb8539628f4168b390fcb3f78e09d">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::isNonZero()</a>.</p>

</div>
</div>
<a id="a43fe35794f33ef8a8b1ccf126c1807c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fe35794f33ef8a8b1ccf126c1807c3">&#9670;&nbsp;</a></span>isNonZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::isNonZero </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the function value is non-zero in the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a3d52dc9c7a85fecedf0b6971a3f783fd">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#afa4dbff44a7f8a5a818c55af0031f5a7">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#ab497fcaa18819bdf5e09c9d9e582f547">inet::math::UnilinearFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#a35f5194ee019716945f24c5b363d003b">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                                                {</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        this-&gt;<a class="code" href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">partition</a>(i, [&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> D::I&amp; i1, <span class="keyword">const</span> IFunction&lt;R, D&gt; *f1) {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            result &amp;= f1-&gt;isNonZero(i1);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        });</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abc1285ba8afd8c62fac7b5c122092531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1285ba8afd8c62fac7b5c122092531">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Ptr&lt;const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt;R, D&gt; &gt; <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; double, D &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the provided function with this function. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a3a8e47212fa99d76e36715367ab221fb">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                                                                                                               {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">return</span> makeShared&lt;MultipliedFunction&lt;R, D&gt;&gt;(<span class="keyword">const_cast&lt;</span>FunctionBase&lt;R, D&gt; *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;shared_from_this(), o);</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a870ff025affae7dbdfb0a7779236ef81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870ff025affae7dbdfb0a7779236ef81">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::partition </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subdivides the provided domain and calls back f with the subdomains and the corresponding potentially simpler domain limited functions. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a521f36a4017a10bbcefa833ea01ee307">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_left_currying_function.html#adfaf0f113c2dd53aab47be42c31bd6a0">inet::math::LeftCurryingFunction&lt; R, C, DIMSC, D, DIMSD, E &gt;</a>, <a class="el" href="classinet_1_1math_1_1_summed_function.html#af31a9e24b8bcbfff1f32d70309559d6f">inet::math::SummedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#ae383be4bc05644b7911c9c93d961edce">inet::math::UnireciprocalFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_multiplied_function.html#a3bab1e315b18c00bb0b85868e5ebe05e">inet::math::MultipliedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#ae2b61133b3d34d8bac0deacd6f726fa7">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_subtracted_function.html#a55aa8ed8cb2e767af2f07a0ccc692268">inet::math::SubtractedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_shifted_function.html#a248a7fd6072d92de2e230ef1593964ba">inet::math::DomainShiftedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#ae1bee13bb1dffee8ac0d5fe5dec3db2d">inet::math::UnilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#a9989f4eebeb0fc4fff01e3ba399049ec">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_added_function.html#add197f7a47fc4419f62a77d2b512fbef">inet::math::AddedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_constant_function.html#a1e2118315a9d9ee8445ba7a4ccb40986">inet::math::ConstantFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_divided_function.html#a42cd6ede4fe718c40d7458f6a441327f">inet::math::DividedFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                                                                                                                                               {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keyword">auto</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#a44d9b2566a438eba4f0f692170691276">m</a> = (1 &lt;&lt; std::tuple_size&lt;typename D::P::type&gt;::value) - 1;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keywordflow">if</span> (i.getFixed() == <a class="code" href="namespaceinet_1_1units_1_1values.html#a44d9b2566a438eba4f0f692170691276">m</a>) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            ASSERT(i.getLower() == i.getUpper());</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            ConstantFunction&lt;R, D&gt; <a class="code" href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">g</a>(this-&gt;<a class="code" href="classinet_1_1math_1_1_i_function.html#a77b27bdf6c6459b2af0211dea54a9c18">getValue</a>(i.getLower()));</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            callback(i, &amp;<a class="code" href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">g</a>);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;Cannot partition %s, interval = %s&quot;</span>, this-&gt;getClassName(), i.str().c_str());</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_space_and_frequency_dependent_attenuation_function.html#a31810b8ad07279fb4b7ed044c66f2804">inet::physicallayer::SpaceAndFrequencyDependentAttenuationFunction::partition()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_space_dependent_attenuation_function.html#a8b72283cc575bb48f592a8f65b656033">inet::physicallayer::SpaceDependentAttenuationFunction::partition()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_background_noise_power_function.html#aecc7f69442b89e3c4443ca3009ddc594">inet::physicallayer::BackgroundNoisePowerFunction::partition()</a>, and <a class="el" href="classinet_1_1physicallayer_1_1_propagated_transmission_power_function.html#ad75219c69f7e8b6e8c65b759708f0929">inet::physicallayer::PropagatedTransmissionPowerFunction::partition()</a>.</p>

</div>
</div>
<a id="a3b1badb187e7b1e32e0377c2c4f35cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1badb187e7b1e32e0377c2c4f35cb4">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints this function in a human readable form to the provided stream for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#ae396b53e2f9fa697c9234a2364a873e8">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                                                                                           {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        os &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;function&quot;</span> &lt;&lt; D() &lt;&lt; <span class="stringliteral">&quot; → &quot;</span>;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <a class="code" href="namespaceinet_1_1math.html#a73ef96a2a4dbe9345f0c3aed7cbd10e8">printUnit</a>(os, <a class="code" href="namespaceinet_1_1units_1_1constants.html#a1a7f5aced244de22a80826323f4f127a">R</a>());</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        os &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot; {\n  domain = &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; → range = &quot;</span> &lt;&lt; <a class="code" href="classinet_1_1math_1_1_function_base.html#a68adbce26e59b9d984f0afabbe8fd7fc">getRange</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        os &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;  structure =\n    &quot;</span>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <a class="code" href="classinet_1_1math_1_1_function_base.html#ac1fbb2e03f24d4964ab9a06155ef0438">printStructure</a>(os, level + 4);</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        os &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        os &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;  partitioning = {\n&quot;</span>;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <a class="code" href="classinet_1_1math_1_1_function_base.html#a6c986f9ac17ad81a15da3089c04b4e21">printPartitioning</a>(os, i, level + 4);</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        os &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;  } min = &quot;</span> &lt;&lt; <a class="code" href="classinet_1_1math_1_1_function_base.html#a36290a0acac3c7521e59b91e1ed0cda7">getMin</a>(i) &lt;&lt; <span class="stringliteral">&quot;, max = &quot;</span> &lt;&lt; <a class="code" href="classinet_1_1math_1_1_function_base.html#afe8ccec5b93a214efd528e120a7b5718">getMax</a>(i) &lt;&lt; <span class="stringliteral">&quot;, mean = &quot;</span> &lt;&lt; <a class="code" href="classinet_1_1math_1_1_function_base.html#a844360abf304a795038a86bdcc08a495">getMean</a>(i) &lt;&lt; <span class="stringliteral">&quot;\n}\n&quot;</span>;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7bb72fc50f58410e87b192e9ab2a2914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb72fc50f58410e87b192e9ab2a2914">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints this function in human readable form to the provided stream for the whole domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a5c895b393114aef7f282f1a42e629ce5">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                                                                     {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <a class="code" href="classinet_1_1math_1_1_function_base.html#a7bb72fc50f58410e87b192e9ab2a2914">print</a>(os, <a class="code" href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">getDomain</a>(), level);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a92b5fb58460be34844ef971372120286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b5fb58460be34844ef971372120286">&#9670;&nbsp;</a></span>printOn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::printOn </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                                                               {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <a class="code" href="classinet_1_1math_1_1_function_base.html#a7bb72fc50f58410e87b192e9ab2a2914">print</a>(os);</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a186d11b46c8fb589798f9319b14fad48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186d11b46c8fb589798f9319b14fad48">&#9670;&nbsp;</a></span>printPartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::printPartition </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a single partition of this function in a human readable form to the provided stream for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a4bd7c5543c8f33d0598d55cac866a02f">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#a4557c5a049ed1413b697ead1f3b5b374">inet::math::UnireciprocalFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#a74e26453476626b35f9ee63f771eb564">inet::math::BilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#abd33e7feb22b4bde33cb3852b5830498">inet::math::UnilinearFunction&lt; R, D &gt;</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#acaea3e5ec003bb8fcf7b569c8a3fcd86">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                                                                                                    {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        os &lt;&lt; <span class="stringliteral">&quot;over &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; → {&quot;</span>;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <a class="code" href="namespaceinet_1_1math.html#af4eca85366c2045bf125108484c18a19">iterateCorners</a>(i, std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> <span class="keyword">typename</span> D::P&amp;)&gt;([&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> D::P&amp; p) {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; std::string(level + 2, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;at &quot;</span> &lt;&lt; p &lt;&lt; <span class="stringliteral">&quot; → &quot;</span> &lt;&lt; this-&gt;<a class="code" href="classinet_1_1math_1_1_i_function.html#a77b27bdf6c6459b2af0211dea54a9c18">getValue</a>(p);</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        }));</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;} min = &quot;</span> &lt;&lt; <a class="code" href="classinet_1_1math_1_1_function_base.html#a36290a0acac3c7521e59b91e1ed0cda7">getMin</a>(i) &lt;&lt; <span class="stringliteral">&quot;, max = &quot;</span> &lt;&lt; <a class="code" href="classinet_1_1math_1_1_function_base.html#afe8ccec5b93a214efd528e120a7b5718">getMax</a>(i) &lt;&lt; <span class="stringliteral">&quot;, mean = &quot;</span> &lt;&lt; <a class="code" href="classinet_1_1math_1_1_function_base.html#a844360abf304a795038a86bdcc08a495">getMean</a>(i) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c986f9ac17ad81a15da3089c04b4e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c986f9ac17ad81a15da3089c04b4e21">&#9670;&nbsp;</a></span>printPartitioning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::printPartitioning </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the partitioning of this function in a human readable form to the provided stream for the given domain. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#ac6fae77979fcafa59e484da17ac0b213">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                                                                                                   {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        this-&gt;<a class="code" href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">partition</a>(i, [&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> D::I&amp; i1, <span class="keyword">const</span> IFunction&lt;R, D&gt; *f1) {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            os &lt;&lt; std::string(level, <span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            f1-&gt;printPartition(os, i1, level);</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        });</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1fbb2e03f24d4964ab9a06155ef0438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fbb2e03f24d4964ab9a06155ef0438">&#9670;&nbsp;</a></span>printStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::printStructure </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the internal data structure of this function in a human readable form to the provided stream. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#ae86ab1820c3b94f6b83eee6ef38639a3">inet::math::IFunction&lt; R, D &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classinet_1_1math_1_1_integrated_function.html#af8ae7955a318bdcd0e7fefc1ef4c8559">inet::math::IntegratedFunction&lt; R, D, DIMS, RI, DI &gt;</a>, <a class="el" href="classinet_1_1math_1_1_interpolated1_d_function.html#a10cfda7f2b8603139eaf66991c66e193">inet::math::Interpolated1DFunction&lt; R, X &gt;</a>, <a class="el" href="classinet_1_1math_1_1_extruded2_d_function.html#aa6e7f0fc1ed3c11a4e149a9a647fec40">inet::math::Extruded2DFunction&lt; R, X, Y &gt;</a>, <a class="el" href="classinet_1_1math_1_1_approximated_function.html#adb4f608f42d86644633058488fcc5756">inet::math::ApproximatedFunction&lt; R, D, DIMENSION, X &gt;</a>, <a class="el" href="classinet_1_1math_1_1_boxcar2_d_function.html#ae1aab30377a87b530c54fa7db7b65c94">inet::math::Boxcar2DFunction&lt; R, X, Y &gt;</a>, <a class="el" href="classinet_1_1math_1_1_summed_function.html#a9efffd69813c1552b4d2d2e80f33fda0">inet::math::SummedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1physicallayer_1_1_obstacle_loss_function.html#a94759c81336de255fcf817b5c0178e55">inet::physicallayer::ObstacleLossFunction</a>, <a class="el" href="classinet_1_1math_1_1_boxcar1_d_function.html#aa55bbda1a522a7b916dcf65cade0586e">inet::math::Boxcar1DFunction&lt; R, X &gt;</a>, <a class="el" href="classinet_1_1physicallayer_1_1_path_loss_function.html#a688d2d719b77b208cb3a838acc6d108e">inet::physicallayer::PathLossFunction</a>, <a class="el" href="classinet_1_1physicallayer_1_1_propagated_transmission_power_function.html#a6b14d2ab6046dde0dd0aa2d18518d8c2">inet::physicallayer::PropagatedTransmissionPowerFunction</a>, <a class="el" href="classinet_1_1math_1_1_divided_function.html#a12657a4ea5a8b14ce109775c83d9966d">inet::math::DividedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1physicallayer_1_1_background_noise_power_function.html#ace3b4fbcf6acb4f55ca4545f4eae2688">inet::physicallayer::BackgroundNoisePowerFunction</a>, <a class="el" href="classinet_1_1math_1_1_combined2_d_function.html#a7c92efeed63152b40611bf9356ee7154">inet::math::Combined2DFunction&lt; R, X, Y &gt;</a>, <a class="el" href="classinet_1_1math_1_1_multiplied_function.html#ab2f33d89f0a913240c445a37ea6d72aa">inet::math::MultipliedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1physicallayer_1_1_space_dependent_attenuation_function.html#a48849e029ecdaeded6bd10b4378b3a09">inet::physicallayer::SpaceDependentAttenuationFunction</a>, <a class="el" href="classinet_1_1math_1_1_subtracted_function.html#ac5e7a355be4927fdbe3ccc2987a9ea6b">inet::math::SubtractedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1physicallayer_1_1_space_and_frequency_dependent_attenuation_function.html#a3df8b09962b4a701dd37215e0620edb8">inet::physicallayer::SpaceAndFrequencyDependentAttenuationFunction</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a11dc31e1121c5a42e3f76a420e3d3b72">inet::math::UnilinearFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_shifted_function.html#a1e9291897c5666bb2441edfa94c1f696">inet::math::DomainShiftedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_added_function.html#a2f9b5c07a403cdf4996c4c19c274ad26">inet::math::AddedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html#af1c4394ebcc84b12854da994dd659bb7">inet::math::DomainLimitedFunction&lt; R, D &gt;</a>, <a class="el" href="classinet_1_1physicallayer_1_1_frequency_dependent_attenuation_function.html#a3dfa6a9c23849f85ec9599000dd537a9">inet::physicallayer::FrequencyDependentAttenuationFunction</a>, and <a class="el" href="classinet_1_1math_1_1_constant_function.html#a3b0150eea0e9f3957f4c60b65d990294">inet::math::ConstantFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                                                                              {</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keyword">auto</span> className = this-&gt;getClassName();</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">if</span> (!strncmp(className, <span class="stringliteral">&quot;inet::math::&quot;</span>, 12))</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            className += 12;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strncmp(className, <span class="stringliteral">&quot;inet::&quot;</span>, 6))</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            className += 6;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        os &lt;&lt; className;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c2ff3af06f9ab3b6dfd8d5409146dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ff3af06f9ab3b6dfd8d5409146dea">&#9670;&nbsp;</a></span>subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const Ptr&lt;const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt;R, D&gt; &gt; <a class="el" href="classinet_1_1math_1_1_function_base.html">inet::math::FunctionBase</a>&lt; R, D &gt;::subtract </td>
          <td>(</td>
          <td class="paramtype">const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substracts the provided function from this function. </p>

<p>Implements <a class="el" href="classinet_1_1math_1_1_i_function.html#a94c773be6e7d828fd9784d83c9118771">inet::math::IFunction&lt; R, D &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                                                                                                          {</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">return</span> makeShared&lt;SubtractedFunction&lt;R, D&gt;&gt;(<span class="keyword">const_cast&lt;</span>FunctionBase&lt;R, D&gt; *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;shared_from_this(), o);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_function_base_8h.html">FunctionBase.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a68adbce26e59b9d984f0afabbe8fd7fc"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a68adbce26e59b9d984f0afabbe8fd7fc">inet::math::FunctionBase::getRange</a></div><div class="ttdeci">virtual Interval&lt; R &gt; getRange() const override</div><div class="ttdoc">Returns the valid range of the function as an interval.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:50</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a844360abf304a795038a86bdcc08a495"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a844360abf304a795038a86bdcc08a495">inet::math::FunctionBase::getMean</a></div><div class="ttdeci">virtual R getMean() const override</div><div class="ttdoc">Returns the mean value for the whole domain.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:98</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_i_function_html_a77b27bdf6c6459b2af0211dea54a9c18"><div class="ttname"><a href="classinet_1_1math_1_1_i_function.html#a77b27bdf6c6459b2af0211dea54a9c18">inet::math::IFunction::getValue</a></div><div class="ttdeci">virtual R getValue(const typename D::P &amp;p) const =0</div><div class="ttdoc">Returns the value of the function at the given point.</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a3cfd3772c21c16e4a455a7f70fcae853"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a3cfd3772c21c16e4a455a7f70fcae853">inet::math::FunctionBase::getDomain</a></div><div class="ttdeci">virtual D::I getDomain() const override</div><div class="ttdoc">Returns the valid domain of the function as an interval.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:58</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1units_html_a9a47d0bb11a9382eda09fa5496199a06"><div class="ttname"><a href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">inet::units::units::g</a></div><div class="ttdeci">milli&lt; kg &gt;::type g</div><div class="ttdef"><b>Definition:</b> Units.h:1071</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_aadcb04b0e7b6f04876f0cadbdb37d7e9"><div class="ttname"><a href="namespaceinet_1_1math.html#aadcb04b0e7b6f04876f0cadbdb37d7e9">inet::math::maxnan</a></div><div class="ttdeci">const T maxnan(const T &amp;a, const T &amp;b)</div><div class="ttdoc">This function properly and symmetrically handles NaNs in contrast with std::max and std::fmax.</div><div class="ttdef"><b>Definition:</b> INETMath.h:234</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_af8dbb8539628f4168b390fcb3f78e09d"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#af8dbb8539628f4168b390fcb3f78e09d">inet::math::FunctionBase::isNonZero</a></div><div class="ttdeci">virtual bool isNonZero() const override</div><div class="ttdoc">Returns true if the function value is non-zero in the whole domain.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:71</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1constants_html_a1a7f5aced244de22a80826323f4f127a"><div class="ttname"><a href="namespaceinet_1_1units_1_1constants.html#a1a7f5aced244de22a80826323f4f127a">inet::units::constants::R</a></div><div class="ttdeci">const value&lt; double, compose&lt; units::J, compose&lt; pow&lt; units::mol, -1 &gt;, pow&lt; units::kg, -1 &gt; &gt; &gt; &gt; R(8.314472)</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a36290a0acac3c7521e59b91e1ed0cda7"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a36290a0acac3c7521e59b91e1ed0cda7">inet::math::FunctionBase::getMin</a></div><div class="ttdeci">virtual R getMin() const override</div><div class="ttdoc">Returns the minimum value for the whole domain.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:80</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a777b60ead65629ce5fc96b2f05338dc9"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a777b60ead65629ce5fc96b2f05338dc9">inet::math::FunctionBase::getIntegral</a></div><div class="ttdeci">virtual R getIntegral() const override</div><div class="ttdoc">Returns the integral value for the whole domain.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:103</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_ac1fbb2e03f24d4964ab9a06155ef0438"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#ac1fbb2e03f24d4964ab9a06155ef0438">inet::math::FunctionBase::printStructure</a></div><div class="ttdeci">virtual void printStructure(std::ostream &amp;os, int level=0) const override</div><div class="ttdoc">Prints the internal data structure of this function in a human readable form to the provided stream.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:167</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a7bb72fc50f58410e87b192e9ab2a2914"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a7bb72fc50f58410e87b192e9ab2a2914">inet::math::FunctionBase::print</a></div><div class="ttdeci">virtual void print(std::ostream &amp;os, int level=0) const override</div><div class="ttdoc">Prints this function in human readable form to the provided stream for the whole domain.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:136</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a870ff025affae7dbdfb0a7779236ef81"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a870ff025affae7dbdfb0a7779236ef81">inet::math::FunctionBase::partition</a></div><div class="ttdeci">virtual void partition(const typename D::I &amp;i, const std::function&lt; void(const typename D::I &amp;, const IFunction&lt; R, D &gt; *)&gt; callback) const override</div><div class="ttdoc">Subdivides the provided domain and calls back f with the subdomains and the corresponding potentially...</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:39</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_a73ef96a2a4dbe9345f0c3aed7cbd10e8"><div class="ttname"><a href="namespaceinet_1_1math.html#a73ef96a2a4dbe9345f0c3aed7cbd10e8">inet::math::printUnit</a></div><div class="ttdeci">void printUnit(std::ostream &amp;os, T v)</div><div class="ttdef"><b>Definition:</b> Point.h:19</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_a6c986f9ac17ad81a15da3089c04b4e21"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#a6c986f9ac17ad81a15da3089c04b4e21">inet::math::FunctionBase::printPartitioning</a></div><div class="ttdeci">virtual void printPartitioning(std::ostream &amp;os, const typename D::I &amp;i, int level) const override</div><div class="ttdoc">Prints the partitioning of this function in a human readable form to the provided stream for the give...</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:152</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_afe8ccec5b93a214efd528e120a7b5718"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#afe8ccec5b93a214efd528e120a7b5718">inet::math::FunctionBase::getMax</a></div><div class="ttdeci">virtual R getMax() const override</div><div class="ttdoc">Returns the maximum value for the whole domain.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:89</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_ab05f5f363b17f9e2cc464f2d812a6295"><div class="ttname"><a href="namespaceinet_1_1math.html#ab05f5f363b17f9e2cc464f2d812a6295">inet::math::minnan</a></div><div class="ttdeci">const T minnan(const T &amp;a, const T &amp;b)</div><div class="ttdoc">This function properly and symmetrically handles NaNs in contrast with std::min and std::fmin.</div><div class="ttdef"><b>Definition:</b> INETMath.h:216</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_af4eca85366c2045bf125108484c18a19"><div class="ttname"><a href="namespaceinet_1_1math.html#af4eca85366c2045bf125108484c18a19">inet::math::iterateCorners</a></div><div class="ttdeci">void iterateCorners(const Interval&lt;&gt; &amp;i, const std::function&lt; void(const Point&lt;&gt; &amp;)&gt; f)</div><div class="ttdef"><b>Definition:</b> Interval.h:186</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1values_html_a44d9b2566a438eba4f0f692170691276"><div class="ttname"><a href="namespaceinet_1_1units_1_1values.html#a44d9b2566a438eba4f0f692170691276">inet::units::values::m</a></div><div class="ttdeci">value&lt; double, units::m &gt; m</div><div class="ttdef"><b>Definition:</b> Units.h:1233</div></div>
<div class="ttc" id="aclassinet_1_1math_1_1_function_base_html_ab11ddb62b77a40cd993fbeb44a3d1e3a"><div class="ttname"><a href="classinet_1_1math_1_1_function_base.html#ab11ddb62b77a40cd993fbeb44a3d1e3a">inet::math::FunctionBase::isFinite</a></div><div class="ttdeci">virtual bool isFinite() const override</div><div class="ttdoc">Returns true if the function value is finite in the whole domain.</div><div class="ttdef"><b>Definition:</b> FunctionBase.h:62</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinet.html">inet</a></li><li class="navelem"><a class="el" href="namespaceinet_1_1math.html">math</a></li><li class="navelem"><a class="el" href="classinet_1_1math_1_1_function_base.html">FunctionBase</a></li>
    <li class="footer">Generated on Sun Apr 10 2022 21:00:33 for INET Framework for OMNeT++/OMNEST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
