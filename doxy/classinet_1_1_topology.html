<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INET Framework for OMNeT++/OMNEST: inet::Topology Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="opp.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classinet_1_1_topology.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classinet_1_1_topology-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">inet::Topology Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Routing support.  
 <a href="classinet_1_1_topology.html#details">More...</a></p>

<p><code>#include &lt;Topology.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for inet::Topology:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classinet_1_1_topology.png" usemap="#inet::Topology_map" alt=""/>
  <map id="inet::Topology_map" name="inet::Topology_map">
<area href="classinet_1_1_l2_network_configurator_1_1_l2_topology.html" alt="inet::L2NetworkConfigurator::L2Topology" shape="rect" coords="0,112,277,136"/>
<area href="classinet_1_1_l3_network_configurator_base_1_1_topology.html" title="Represents the network topology." alt="inet::L3NetworkConfiguratorBase::Topology" shape="rect" coords="287,112,564,136"/>
<area href="classinet_1_1_network_configurator_base_1_1_topology.html" alt="inet::NetworkConfiguratorBase::Topology" shape="rect" coords="574,112,851,136"/>
<area href="classinet_1_1_ipv4_network_configurator_1_1_topology.html" alt="inet::Ipv4NetworkConfigurator::Topology" shape="rect" coords="287,168,564,192"/>
<area href="classinet_1_1_stream_redundancy_configurator_1_1_topology.html" alt="inet::StreamRedundancyConfigurator::Topology" shape="rect" coords="574,168,851,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supporting class for <a class="el" href="classinet_1_1_topology.html" title="Routing support.">Topology</a>, represents a link in the graph.  <a href="classinet_1_1_topology_1_1_link.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supporting class for <a class="el" href="classinet_1_1_topology.html" title="Routing support.">Topology</a>, represents a node in the graph.  <a href="classinet_1_1_topology_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology_1_1_predicate.html">Predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for selector objects used in extract...() methods of <a class="el" href="classinet_1_1_topology.html" title="Routing support.">Topology</a>.  <a href="classinet_1_1_topology_1_1_predicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor, assignment</div></td></tr>
<tr class="memitem:a96c1eb8c582a690828e2cd23eca458aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a96c1eb8c582a690828e2cd23eca458aa">Topology</a> (const char *name=nullptr)</td></tr>
<tr class="memdesc:a96c1eb8c582a690828e2cd23eca458aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classinet_1_1_topology.html#a96c1eb8c582a690828e2cd23eca458aa">More...</a><br /></td></tr>
<tr class="separator:a96c1eb8c582a690828e2cd23eca458aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c649c26f6b57ff3611b82a22c3b682e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a4c649c26f6b57ff3611b82a22c3b682e">Topology</a> (const <a class="el" href="classinet_1_1_topology.html">Topology</a> &amp;topo)</td></tr>
<tr class="memdesc:a4c649c26f6b57ff3611b82a22c3b682e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classinet_1_1_topology.html#a4c649c26f6b57ff3611b82a22c3b682e">More...</a><br /></td></tr>
<tr class="separator:a4c649c26f6b57ff3611b82a22c3b682e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21288a2fea2d283ebc53f01bafa36043"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a21288a2fea2d283ebc53f01bafa36043">~Topology</a> ()</td></tr>
<tr class="memdesc:a21288a2fea2d283ebc53f01bafa36043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classinet_1_1_topology.html#a21288a2fea2d283ebc53f01bafa36043">More...</a><br /></td></tr>
<tr class="separator:a21288a2fea2d283ebc53f01bafa36043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d911ba65804d10b0f89284f4835c7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1_topology.html">Topology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a5d911ba65804d10b0f89284f4835c7c7">operator=</a> (const <a class="el" href="classinet_1_1_topology.html">Topology</a> &amp;topo)</td></tr>
<tr class="memdesc:a5d911ba65804d10b0f89284f4835c7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classinet_1_1_topology.html#a5d911ba65804d10b0f89284f4835c7c7">More...</a><br /></td></tr>
<tr class="separator:a5d911ba65804d10b0f89284f4835c7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions.</div></td></tr>
<tr class="memitem:aa2e58f44b9081b12bf8c545fed69b1ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classinet_1_1_topology.html">Topology</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#aa2e58f44b9081b12bf8c545fed69b1ed">dup</a> () const override</td></tr>
<tr class="memdesc:aa2e58f44b9081b12bf8c545fed69b1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an exact copy of this object.  <a href="classinet_1_1_topology.html#aa2e58f44b9081b12bf8c545fed69b1ed">More...</a><br /></td></tr>
<tr class="separator:aa2e58f44b9081b12bf8c545fed69b1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49be07cc21ff68bec558d787576a3a3"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#ac49be07cc21ff68bec558d787576a3a3">str</a> () const override</td></tr>
<tr class="memdesc:ac49be07cc21ff68bec558d787576a3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a one-line description of the object's contents.  <a href="classinet_1_1_topology.html#ac49be07cc21ff68bec558d787576a3a3">More...</a><br /></td></tr>
<tr class="separator:ac49be07cc21ff68bec558d787576a3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14dce65d390c3868464c41e2f45740d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#ae14dce65d390c3868464c41e2f45740d">parsimPack</a> (cCommBuffer *buffer) const override</td></tr>
<tr class="memdesc:ae14dce65d390c3868464c41e2f45740d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the object into an MPI send buffer.  <a href="classinet_1_1_topology.html#ae14dce65d390c3868464c41e2f45740d">More...</a><br /></td></tr>
<tr class="separator:ae14dce65d390c3868464c41e2f45740d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ebcc6fd7722ceab87bbd129cc16703"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a05ebcc6fd7722ceab87bbd129cc16703">parsimUnpack</a> (cCommBuffer *buffer) override</td></tr>
<tr class="memdesc:a05ebcc6fd7722ceab87bbd129cc16703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes the object from an MPI receive buffer Used by the simulation kernel for parallel execution.  <a href="classinet_1_1_topology.html#a05ebcc6fd7722ceab87bbd129cc16703">More...</a><br /></td></tr>
<tr class="separator:a05ebcc6fd7722ceab87bbd129cc16703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extracting the topology from a network.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>extract...() functions build topology from the model.</p>
<p>User can select which modules to include. All connections between those modules will be in the topology. Connections can cross compound module boundaries. </p>
</div></td></tr>
<tr class="memitem:a0d7b227585c394dd6b195c8e7f0f129f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork</a> (bool(*selfunc)(cModule *, void *), void *userdata=nullptr)</td></tr>
<tr class="memdesc:a0d7b227585c394dd6b195c8e7f0f129f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts model topology by a user-defined criteria.  <a href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">More...</a><br /></td></tr>
<tr class="separator:a0d7b227585c394dd6b195c8e7f0f129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d3a31e341322df26afc0352542a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a4c6d3a31e341322df26afc0352542a73">extractFromNetwork</a> (<a class="el" href="classinet_1_1_topology_1_1_predicate.html">Predicate</a> *predicate)</td></tr>
<tr class="memdesc:a4c6d3a31e341322df26afc0352542a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type safe, object-oriented equivalent of extractFromNetwork(selfunc, userdata).  <a href="classinet_1_1_topology.html#a4c6d3a31e341322df26afc0352542a73">More...</a><br /></td></tr>
<tr class="separator:a4c6d3a31e341322df26afc0352542a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff007f5cffa94466a5aa65a1fd9441ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#aff007f5cffa94466a5aa65a1fd9441ec">extractByModulePath</a> (const std::vector&lt; std::string &gt; &amp;fullPathPatterns)</td></tr>
<tr class="memdesc:aff007f5cffa94466a5aa65a1fd9441ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts model topology by module full path.  <a href="classinet_1_1_topology.html#aff007f5cffa94466a5aa65a1fd9441ec">More...</a><br /></td></tr>
<tr class="separator:aff007f5cffa94466a5aa65a1fd9441ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c519b0b9a31e5b8053051ea16ae307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a35c519b0b9a31e5b8053051ea16ae307">extractByNedTypeName</a> (const std::vector&lt; std::string &gt; &amp;nedTypeNames)</td></tr>
<tr class="memdesc:a35c519b0b9a31e5b8053051ea16ae307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts model topology by the fully qualified NED type name of the modules.  <a href="classinet_1_1_topology.html#a35c519b0b9a31e5b8053051ea16ae307">More...</a><br /></td></tr>
<tr class="separator:a35c519b0b9a31e5b8053051ea16ae307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe25ad92498a0990119c065012c7131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a4fe25ad92498a0990119c065012c7131">extractByProperty</a> (const char *propertyName, const char *value=nullptr)</td></tr>
<tr class="memdesc:a4fe25ad92498a0990119c065012c7131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts model topology by a module property.  <a href="classinet_1_1_topology.html#a4fe25ad92498a0990119c065012c7131">More...</a><br /></td></tr>
<tr class="separator:a4fe25ad92498a0990119c065012c7131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f9999b154df2884dfd29da1b5f74ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#ad5f9999b154df2884dfd29da1b5f74ae">extractByParameter</a> (const char *paramName, const char *paramValue=nullptr)</td></tr>
<tr class="memdesc:ad5f9999b154df2884dfd29da1b5f74ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts model topology by a module parameter.  <a href="classinet_1_1_topology.html#ad5f9999b154df2884dfd29da1b5f74ae">More...</a><br /></td></tr>
<tr class="separator:ad5f9999b154df2884dfd29da1b5f74ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4807e7915fbc2b1c8ecf0d217088399a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a4807e7915fbc2b1c8ecf0d217088399a">clear</a> ()</td></tr>
<tr class="memdesc:a4807e7915fbc2b1c8ecf0d217088399a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the topology stored in the object.  <a href="classinet_1_1_topology.html#a4807e7915fbc2b1c8ecf0d217088399a">More...</a><br /></td></tr>
<tr class="separator:a4807e7915fbc2b1c8ecf0d217088399a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulating the graph.</div></td></tr>
<tr class="memitem:aa3d1c482760c38b804098416d2752719"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#aa3d1c482760c38b804098416d2752719">addNode</a> (<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:aa3d1c482760c38b804098416d2752719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given node to the graph.  <a href="classinet_1_1_topology.html#aa3d1c482760c38b804098416d2752719">More...</a><br /></td></tr>
<tr class="separator:aa3d1c482760c38b804098416d2752719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ea22a249a17f6283e65220193090a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a47ea22a249a17f6283e65220193090a0">deleteNode</a> (<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a47ea22a249a17f6283e65220193090a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given node from the graph, together with all of its links.  <a href="classinet_1_1_topology.html#a47ea22a249a17f6283e65220193090a0">More...</a><br /></td></tr>
<tr class="separator:a47ea22a249a17f6283e65220193090a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f46fb3abb301aba36ccdede6221b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a01f46fb3abb301aba36ccdede6221b21">addLink</a> (<a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *link, <a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *srcNode, <a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *destNode)</td></tr>
<tr class="memdesc:a01f46fb3abb301aba36ccdede6221b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO Note: also serves as reconnectLink()  <a href="classinet_1_1_topology.html#a01f46fb3abb301aba36ccdede6221b21">More...</a><br /></td></tr>
<tr class="separator:a01f46fb3abb301aba36ccdede6221b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb3ef43d4dfcfe7a8f4b9dc6e63e498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a4bb3ef43d4dfcfe7a8f4b9dc6e63e498">addLink</a> (<a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *link, cGate *srcGate, cGate *destGate)</td></tr>
<tr class="memdesc:a4bb3ef43d4dfcfe7a8f4b9dc6e63e498"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO Note: also serves as reconnectLink()  <a href="classinet_1_1_topology.html#a4bb3ef43d4dfcfe7a8f4b9dc6e63e498">More...</a><br /></td></tr>
<tr class="separator:a4bb3ef43d4dfcfe7a8f4b9dc6e63e498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57fd36fa6fbe8f2ace22894fc583fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#ab57fd36fa6fbe8f2ace22894fc583fb1">deleteLink</a> (<a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *link)</td></tr>
<tr class="memdesc:ab57fd36fa6fbe8f2ace22894fc583fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given link from the graph.  <a href="classinet_1_1_topology.html#ab57fd36fa6fbe8f2ace22894fc583fb1">More...</a><br /></td></tr>
<tr class="separator:ab57fd36fa6fbe8f2ace22894fc583fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to examine topology by hand.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Users also need to rely on <a class="el" href="classinet_1_1_topology_1_1_node.html" title="Supporting class for Topology, represents a node in the graph.">Node</a> and <a class="el" href="classinet_1_1_topology_1_1_link.html" title="Supporting class for Topology, represents a link in the graph.">Link</a> member functions to explore the graph stored in the object. </p>
</div></td></tr>
<tr class="memitem:aa260c302d257232f55485668b0d184a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#aa260c302d257232f55485668b0d184a0">getNumNodes</a> () const</td></tr>
<tr class="memdesc:aa260c302d257232f55485668b0d184a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the graph.  <a href="classinet_1_1_topology.html#aa260c302d257232f55485668b0d184a0">More...</a><br /></td></tr>
<tr class="separator:aa260c302d257232f55485668b0d184a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa5ab2e1148005506e91facd800ef68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#aaaa5ab2e1148005506e91facd800ef68">getNode</a> (int i) const</td></tr>
<tr class="memdesc:aaaa5ab2e1148005506e91facd800ef68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the ith node in the graph.  <a href="classinet_1_1_topology.html#aaaa5ab2e1148005506e91facd800ef68">More...</a><br /></td></tr>
<tr class="separator:aaaa5ab2e1148005506e91facd800ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83dbad494392c1a5e63e43577198bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">getNodeFor</a> (cModule *mod) const</td></tr>
<tr class="memdesc:ad83dbad494392c1a5e63e43577198bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the graph node which corresponds to the given module in the network.  <a href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">More...</a><br /></td></tr>
<tr class="separator:ad83dbad494392c1a5e63e43577198bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5c84757f6a56ba7c00be8d4d7ca25bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a5c84757f6a56ba7c00be8d4d7ca25bc7">unlinkFromSourceNode</a> (<a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *link)</td></tr>
<tr class="separator:a5c84757f6a56ba7c00be8d4d7ca25bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc51993c1e0dd6c3d62f9f43a089e00e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#abc51993c1e0dd6c3d62f9f43a089e00e">unlinkFromDestNode</a> (<a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *link)</td></tr>
<tr class="separator:abc51993c1e0dd6c3d62f9f43a089e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473823ca721e0c7d833aa7464e0e3fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a473823ca721e0c7d833aa7464e0e3fa9">findNetworks</a> (<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *)</td></tr>
<tr class="separator:a473823ca721e0c7d833aa7464e0e3fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af9e3dddf75691776de3a8641ad48bd22"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#af9e3dddf75691776de3a8641ad48bd22">lessByModuleId</a> (<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *a, <a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *<a class="el" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</td></tr>
<tr class="separator:af9e3dddf75691776de3a8641ad48bd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7255ea09bbd2dfbf7368e592eb183741"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a7255ea09bbd2dfbf7368e592eb183741">isModuleIdLess</a> (<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *a, int moduleId)</td></tr>
<tr class="separator:a7255ea09bbd2dfbf7368e592eb183741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aec5f18015f721d0343ba4dfffcf728ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a></td></tr>
<tr class="separator:aec5f18015f721d0343ba4dfffcf728ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Algorithms to find shortest paths.</h2></td></tr>
<tr class="memitem:a4942b49db44f2ee0038b15b087c7bad0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a4942b49db44f2ee0038b15b087c7bad0">createNode</a> (cModule *module)</td></tr>
<tr class="memdesc:a4942b49db44f2ee0038b15b087c7bad0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classinet_1_1_topology_1_1_node.html" title="Supporting class for Topology, represents a node in the graph.">Node</a> factory.  <a href="classinet_1_1_topology.html#a4942b49db44f2ee0038b15b087c7bad0">More...</a><br /></td></tr>
<tr class="separator:a4942b49db44f2ee0038b15b087c7bad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bf87fee674ecd44885b1c53074579f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a76bf87fee674ecd44885b1c53074579f">createLink</a> ()</td></tr>
<tr class="memdesc:a76bf87fee674ecd44885b1c53074579f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classinet_1_1_topology_1_1_link.html" title="Supporting class for Topology, represents a link in the graph.">Link</a> factory.  <a href="classinet_1_1_topology.html#a76bf87fee674ecd44885b1c53074579f">More...</a><br /></td></tr>
<tr class="separator:a76bf87fee674ecd44885b1c53074579f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee4d5d41ecae9a2a3e7672d4aa9f598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a8ee4d5d41ecae9a2a3e7672d4aa9f598">calculateUnweightedSingleShortestPathsTo</a> (<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *target) const</td></tr>
<tr class="memdesc:a8ee4d5d41ecae9a2a3e7672d4aa9f598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Dijkstra algorithm to find all shortest paths to the given graph node.  <a href="classinet_1_1_topology.html#a8ee4d5d41ecae9a2a3e7672d4aa9f598">More...</a><br /></td></tr>
<tr class="separator:a8ee4d5d41ecae9a2a3e7672d4aa9f598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9680f0f189bfc1aa59c9c06746507a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1_topology.html#a9680f0f189bfc1aa59c9c06746507a73">calculateWeightedSingleShortestPathsTo</a> (<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *target) const</td></tr>
<tr class="memdesc:a9680f0f189bfc1aa59c9c06746507a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Dijkstra algorithm to find all shortest paths to the given graph node.  <a href="classinet_1_1_topology.html#a9680f0f189bfc1aa59c9c06746507a73">More...</a><br /></td></tr>
<tr class="separator:a9680f0f189bfc1aa59c9c06746507a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routing support. </p>
<p>The <a class="el" href="classinet_1_1_topology.html" title="Routing support.">Topology</a> class was designed primarily to support routing in telecommunication or multiprocessor networks.</p>
<p>A <a class="el" href="classinet_1_1_topology.html" title="Routing support.">Topology</a> object stores an abstract representation of the network in graph form: </p><ul>
<li>
each <a class="el" href="classinet_1_1_topology.html" title="Routing support.">Topology</a> node corresponds to a module (simple or compound), and </li>
<li>
each <a class="el" href="classinet_1_1_topology.html" title="Routing support.">Topology</a> edge corresponds to a link or series of connecting links. </li>
</ul>
<p>You can specify which modules (either simple or compound) you want to include in the graph. The graph will include all connections among the selected modules. In the graph, all nodes are at the same level, there is no submodule nesting. Connections which span across compound module boundaries are also represented as one graph edge. Graph edges are directed, just as module gates are.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classinet_1_1_topology_1_1_node.html" title="Supporting class for Topology, represents a node in the graph.">Topology::Node</a>, <a class="el" href="classinet_1_1_topology_1_1_link.html" title="Supporting class for Topology, represents a link in the graph.">Topology::Link</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a96c1eb8c582a690828e2cd23eca458aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c1eb8c582a690828e2cd23eca458aa">&#9670;&nbsp;</a></span>Topology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inet::Topology::Topology </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                   : cOwnedObject(name)</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;{</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c649c26f6b57ff3611b82a22c3b682e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c649c26f6b57ff3611b82a22c3b682e">&#9670;&nbsp;</a></span>Topology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inet::Topology::Topology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinet_1_1_topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                                       : cOwnedObject(topo)</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="keywordflow">throw</span> cRuntimeError(<span class="keyword">this</span>, <span class="stringliteral">&quot;copy ctor not implemented yet&quot;</span>);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a21288a2fea2d283ebc53f01bafa36043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21288a2fea2d283ebc53f01bafa36043">&#9670;&nbsp;</a></span>~Topology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inet::Topology::~Topology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>Reimplemented in <a class="el" href="classinet_1_1_l3_network_configurator_base_1_1_topology.html#ac74184340fadc99d11cbadc06f4b4e48">inet::L3NetworkConfiguratorBase::Topology</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;{</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a4807e7915fbc2b1c8ecf0d217088399a">clear</a>();</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4bb3ef43d4dfcfe7a8f4b9dc6e63e498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb3ef43d4dfcfe7a8f4b9dc6e63e498">&#9670;&nbsp;</a></span>addLink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::addLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cGate *&#160;</td>
          <td class="paramname"><em>srcGate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cGate *&#160;</td>
          <td class="paramname"><em>destGate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO Note: also serves as reconnectLink() </p>
<div class="fragment"><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;{</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="comment">// remove from graph if it&#39;s already in</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">if</span> (link-&gt;srcNode)</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <a class="code" href="classinet_1_1_topology.html#a5c84757f6a56ba7c00be8d4d7ca25bc7">unlinkFromSourceNode</a>(link);</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordflow">if</span> (link-&gt;destNode)</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <a class="code" href="classinet_1_1_topology.html#abc51993c1e0dd6c3d62f9f43a089e00e">unlinkFromDestNode</a>(link);</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160; </div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="comment">// insert</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    Node *srcNode = <a class="code" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">getNodeFor</a>(srcGate-&gt;getOwnerModule());</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    Node *destNode = <a class="code" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">getNodeFor</a>(destGate-&gt;getOwnerModule());</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <span class="keywordflow">if</span> (!srcNode)</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;cTopology::addLink: module of source gate \&quot;%s\&quot; is not in the graph&quot;</span>, srcGate-&gt;getFullPath().c_str());</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="keywordflow">if</span> (!destNode)</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;cTopology::addLink: module of destination gate \&quot;%s\&quot; is not in the graph&quot;</span>, destGate-&gt;getFullPath().c_str());</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    link-&gt;srcNode = srcNode;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    link-&gt;destNode = destNode;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    link-&gt;srcGateId = srcGate-&gt;getId();</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    link-&gt;destGateId = destGate-&gt;getId();</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    srcNode-&gt;outLinks.push_back(link);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    destNode-&gt;inLinks.push_back(link);</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a01f46fb3abb301aba36ccdede6221b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f46fb3abb301aba36ccdede6221b21">&#9670;&nbsp;</a></span>addLink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::addLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>srcNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>destNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO Note: also serves as reconnectLink() </p>
<div class="fragment"><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;{</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="comment">// remove from graph if it&#39;s already in</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="keywordflow">if</span> (link-&gt;srcNode)</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <a class="code" href="classinet_1_1_topology.html#a5c84757f6a56ba7c00be8d4d7ca25bc7">unlinkFromSourceNode</a>(link);</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="keywordflow">if</span> (link-&gt;destNode)</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <a class="code" href="classinet_1_1_topology.html#abc51993c1e0dd6c3d62f9f43a089e00e">unlinkFromDestNode</a>(link);</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160; </div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="comment">// insert</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <span class="keywordflow">if</span> (link-&gt;srcNode != srcNode)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        link-&gt;srcGateId = -1;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <span class="keywordflow">if</span> (link-&gt;destNode != destNode)</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        link-&gt;destGateId = -1;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    link-&gt;srcNode = srcNode;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    link-&gt;destNode = destNode;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    srcNode-&gt;outLinks.push_back(link);</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    destNode-&gt;inLinks.push_back(link);</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a1f37759d507052aee49de5e18fd2564c">inet::L3NetworkConfiguratorBase::extractTopology()</a>.</p>

</div>
</div>
<a id="aa3d1c482760c38b804098416d2752719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d1c482760c38b804098416d2752719">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int inet::Topology::addNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given node to the graph. </p>
<p>Returns the index of the new graph node (see getNode(int)). Indices of existing graph nodes may change. </p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;{</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <span class="keywordflow">if</span> (node-&gt;moduleId == -1) {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="comment">// elements without module ID are stored at the end</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.push_back(node);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.size() - 1;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    }</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="comment">// must find an insertion point because nodes[] is ordered by module ID</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keyword">auto</span> it = std::lower_bound(<a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.begin(), <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.end(), node, <a class="code" href="classinet_1_1_topology.html#af9e3dddf75691776de3a8641ad48bd22">lessByModuleId</a>);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        it = <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.insert(it, node);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="keywordflow">return</span> it - <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.begin();</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ee4d5d41ecae9a2a3e7672d4aa9f598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee4d5d41ecae9a2a3e7672d4aa9f598">&#9670;&nbsp;</a></span>calculateUnweightedSingleShortestPathsTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::calculateUnweightedSingleShortestPathsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the Dijkstra algorithm to find all shortest paths to the given graph node. </p>
<p>The paths found can be extracted via <a class="el" href="classinet_1_1_topology_1_1_node.html" title="Supporting class for Topology, represents a node in the graph.">Node</a>'s methods. </p>
<div class="fragment"><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;{</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="comment">// multiple paths not supported :-(</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160; </div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">if</span> (!_target)</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keywordflow">throw</span> cRuntimeError(<span class="keyword">this</span>, <span class="stringliteral">&quot;..ShortestPathTo(): target node is nullptr&quot;</span>);</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="keyword">auto</span> target = _target;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160; </div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>) {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        elem-&gt;dist = <a class="code" href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a>;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        elem-&gt;outPaths.clear();</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    }</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    target-&gt;dist = 0;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160; </div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    std::deque&lt;Node *&gt; q;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160; </div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    q.push_back(target);</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160; </div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">while</span> (!q.empty()) {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        Node *v = q.front();</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        q.pop_front();</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160; </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="comment">// for each w adjacent to v...</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; v-&gt;inLinks.size(); i++) {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            <span class="keywordflow">if</span> (!v-&gt;inLinks[i]-&gt;enabled)</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160; </div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;            Node *w = v-&gt;inLinks[i]-&gt;srcNode;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            <span class="keywordflow">if</span> (!w-&gt;enabled)</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160; </div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;            <span class="keywordflow">if</span> (w-&gt;dist == <a class="code" href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a>) {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                w-&gt;dist = v-&gt;dist + 1;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                q.push_back(w);</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            }</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            <span class="comment">// the first one will be the shortest</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="namespaceinet.html#ab4f59162a287d7a85fde3ca104470c6e">contains</a>(w-&gt;outPaths, v-&gt;inLinks[i]))</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                w-&gt;outPaths.push_back(v-&gt;inLinks[i]);</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    }</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_network_configurator_base.html#a83350de8892920ce3eccc45484a55409">inet::NetworkConfiguratorBase::computeShortestLinkPath()</a>, and <a class="el" href="classinet_1_1_network_configurator_base.html#a35667ba0ef61768e70e0a1602aa625b2">inet::NetworkConfiguratorBase::computeShortestNodePath()</a>.</p>

</div>
</div>
<a id="a9680f0f189bfc1aa59c9c06746507a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9680f0f189bfc1aa59c9c06746507a73">&#9670;&nbsp;</a></span>calculateWeightedSingleShortestPathsTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::calculateWeightedSingleShortestPathsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the Dijkstra algorithm to find all shortest paths to the given graph node. </p>
<p>The paths found can be extracted via <a class="el" href="classinet_1_1_topology_1_1_node.html" title="Supporting class for Topology, represents a node in the graph.">Node</a>'s methods. Uses weights in nodes and links. </p>
<div class="fragment"><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;{</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="keywordflow">if</span> (!_target)</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        <span class="keywordflow">throw</span> cRuntimeError(<span class="keyword">this</span>, <span class="stringliteral">&quot;..ShortestPathTo(): target node is nullptr&quot;</span>);</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="keyword">auto</span> target = _target;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160; </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="comment">// clean path infos</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>) {</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        elem-&gt;dist = <a class="code" href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a>;</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        elem-&gt;outPaths.clear();</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    }</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160; </div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    target-&gt;dist = 0;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160; </div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    std::list&lt;Node *&gt; q;</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160; </div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    q.push_back(target);</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160; </div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="keywordflow">while</span> (!q.empty()) {</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        Node *dest = q.front();</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        q.pop_front();</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160; </div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        ASSERT(dest-&gt;getWeight() &gt;= 0.0);</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160; </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        <span class="comment">// for each w adjacent to v...</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dest-&gt;getNumInLinks(); i++) {</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            <span class="keywordflow">if</span> (!(dest-&gt;getLinkIn(i)-&gt;isEnabled()))</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160; </div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            Node *src = dest-&gt;getLinkIn(i)-&gt;getLinkInRemoteNode();</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            <span class="keywordflow">if</span> (!src-&gt;isEnabled())</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; </div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;            <span class="keywordtype">double</span> linkWeight = dest-&gt;getLinkIn(i)-&gt;getWeight();</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160; </div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="comment">// links with linkWeight == 0 might induce circles</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            ASSERT(linkWeight &gt; 0.0);</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160; </div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            <span class="keywordtype">double</span> newdist = dest-&gt;dist + linkWeight;</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            <span class="keywordflow">if</span> (dest != target)</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                newdist += dest-&gt;getWeight(); <span class="comment">// dest is not the target, uses weight of dest node as price of routing (infinity means dest node doesn&#39;t route between interfaces)</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;            <span class="keywordflow">if</span> (newdist != <a class="code" href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a> &amp;&amp; src-&gt;dist &gt; newdist) { <span class="comment">// it&#39;s a valid shorter path from src to target node</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                <span class="keywordflow">if</span> (src-&gt;dist != <a class="code" href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a>)</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                    q.remove(src); <span class="comment">// src is in the queue</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                src-&gt;dist = newdist;</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                <span class="comment">// the first one will be the shortest</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                src-&gt;outPaths.erase(<a class="code" href="namespaceinet.html#a0d52548b78348f043858dcb54d8c1e11">std::remove</a>(src-&gt;outPaths.begin(), src-&gt;outPaths.end(), dest-&gt;inLinks[i]), src-&gt;outPaths.end());</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                src-&gt;outPaths.insert(src-&gt;outPaths.begin(), dest-&gt;inLinks[i]);</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160; </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                <span class="comment">// insert src node to ordered list</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                <span class="keyword">auto</span> it = q.begin();</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                <span class="keywordflow">for</span> (; it != q.end(); ++it)</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                    <span class="keywordflow">if</span> ((*it)-&gt;dist &gt; newdist)</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160; </div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                q.insert(it, src);</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;            }</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="namespaceinet.html#ab4f59162a287d7a85fde3ca104470c6e">contains</a>(src-&gt;outPaths, dest-&gt;inLinks[i]))</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                src-&gt;outPaths.push_back(dest-&gt;inLinks[i]);</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        }</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    }</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_next_hop_network_configurator.html#a092f0098e1756298a5342a3d8dc4045f">inet::NextHopNetworkConfigurator::addStaticRoutes()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#af09601980aa83478c7c7416c572be249">inet::Ipv4NetworkConfigurator::addStaticRoutes()</a>, and <a class="el" href="classinet_1_1_mac_forwarding_table_configurator.html#a7614dd25a13d0a89b7eaf219df65f5f6">inet::MacForwardingTableConfigurator::extendConfiguration()</a>.</p>

</div>
</div>
<a id="a4807e7915fbc2b1c8ecf0d217088399a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4807e7915fbc2b1c8ecf0d217088399a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the topology stored in the object. </p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;{</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>) {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; _j : elem-&gt;outLinks)</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="keyword">delete</span> _j; <span class="comment">// delete links from their source side</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keyword">delete</span> elem;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    }</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.clear();</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#ae6e480eb713b5c5c38cb497879dc3029">inet::StreamRedundancyConfigurator::clearConfiguration()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#ad24c449f247e1cf06e155db76d5716ca">inet::GateScheduleConfiguratorBase::clearConfiguration()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a895e6a2da357a1840ef1c2035ee9a434">inet::Ipv4NetworkConfigurator::computeConfiguration()</a>, <a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork()</a>, and <a class="el" href="classinet_1_1_topology.html#a21288a2fea2d283ebc53f01bafa36043">~Topology()</a>.</p>

</div>
</div>
<a id="a76bf87fee674ecd44885b1c53074579f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bf87fee674ecd44885b1c53074579f">&#9670;&nbsp;</a></span>createLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a>* inet::Topology::createLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classinet_1_1_topology_1_1_link.html" title="Supporting class for Topology, represents a link in the graph.">Link</a> factory. </p>

<p>Reimplemented in <a class="el" href="classinet_1_1_l3_network_configurator_base_1_1_topology.html#a255e8c94da2c1366ab17aeee2f94de78">inet::L3NetworkConfiguratorBase::Topology</a>, <a class="el" href="classinet_1_1_l2_network_configurator_1_1_l2_topology.html#aea59f500f0bf06c4ca25f2642960e8c2">inet::L2NetworkConfigurator::L2Topology</a>, and <a class="el" href="classinet_1_1_network_configurator_base_1_1_topology.html#a2430b5f9d67256586458ffa43c00ec38">inet::NetworkConfiguratorBase::Topology</a>.</p>
<div class="fragment"><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;{ <span class="keywordflow">return</span> <span class="keyword">new</span> Link(); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork()</a>.</p>

</div>
</div>
<a id="a4942b49db44f2ee0038b15b087c7bad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4942b49db44f2ee0038b15b087c7bad0">&#9670;&nbsp;</a></span>createNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a>* inet::Topology::createNode </td>
          <td>(</td>
          <td class="paramtype">cModule *&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classinet_1_1_topology_1_1_node.html" title="Supporting class for Topology, represents a node in the graph.">Node</a> factory. </p>

<p>Reimplemented in <a class="el" href="classinet_1_1_l3_network_configurator_base_1_1_topology.html#a48cc1304369e4c83dccb7011a50011b5">inet::L3NetworkConfiguratorBase::Topology</a>, <a class="el" href="classinet_1_1_l2_network_configurator_1_1_l2_topology.html#a0bc162da8b53e55bdf3324f85936d67d">inet::L2NetworkConfigurator::L2Topology</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator_1_1_topology.html#a077f3ea0d1b4f5c3a5c1e4c801e69831">inet::StreamRedundancyConfigurator::Topology</a>, <a class="el" href="classinet_1_1_network_configurator_base_1_1_topology.html#ac5688a4f64d53148a9e4e5331f59f6fa">inet::NetworkConfiguratorBase::Topology</a>, and <a class="el" href="classinet_1_1_ipv4_network_configurator_1_1_topology.html#a2d2e57d90a5d46b69aa3cdcf55c85192">inet::Ipv4NetworkConfigurator::Topology</a>.</p>
<div class="fragment"><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;{ <span class="keywordflow">return</span> <span class="keyword">new</span> Node(module-&gt;getId()); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork()</a>.</p>

</div>
</div>
<a id="ab57fd36fa6fbe8f2ace22894fc583fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57fd36fa6fbe8f2ace22894fc583fb1">&#9670;&nbsp;</a></span>deleteLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::deleteLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given link from the graph. </p>
<p>Indices of existing links in the source and destination nodes may change. </p>
<div class="fragment"><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;{</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a5c84757f6a56ba7c00be8d4d7ca25bc7">unlinkFromSourceNode</a>(link);</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <a class="code" href="classinet_1_1_topology.html#abc51993c1e0dd6c3d62f9f43a089e00e">unlinkFromDestNode</a>(link);</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="keyword">delete</span> link;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a47ea22a249a17f6283e65220193090a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ea22a249a17f6283e65220193090a0">&#9670;&nbsp;</a></span>deleteNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::deleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given node from the graph, together with all of its links. </p>
<p>Indices of existing graph nodes may change. </p>
<div class="fragment"><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;{</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="comment">// remove outgoing links</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : node-&gt;outLinks) {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        Link *link = elem;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <a class="code" href="classinet_1_1_topology.html#abc51993c1e0dd6c3d62f9f43a089e00e">unlinkFromDestNode</a>(link);</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keyword">delete</span> link;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    node-&gt;outLinks.clear();</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160; </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="comment">// remove incoming links</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : node-&gt;inLinks) {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        Link *link = elem;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <a class="code" href="classinet_1_1_topology.html#a5c84757f6a56ba7c00be8d4d7ca25bc7">unlinkFromSourceNode</a>(link);</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        <span class="keyword">delete</span> link;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    node-&gt;inLinks.clear();</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160; </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="comment">// remove from nodes[]</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keyword">auto</span> it = <a class="code" href="namespaceinet.html#a5c4aab0dc099233ae85fac1980ea909a">find</a>(<a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>, node);</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    ASSERT(it != <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.end());</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.erase(it);</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160; </div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="keyword">delete</span> node;</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2e58f44b9081b12bf8c545fed69b1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e58f44b9081b12bf8c545fed69b1ed">&#9670;&nbsp;</a></span>dup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classinet_1_1_topology.html">Topology</a>* inet::Topology::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns an exact copy of this object. </p>
<p>See cObject for more details. </p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classinet_1_1_topology.html#a96c1eb8c582a690828e2cd23eca458aa">Topology</a>(*<span class="keyword">this</span>); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff007f5cffa94466a5aa65a1fd9441ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff007f5cffa94466a5aa65a1fd9441ec">&#9670;&nbsp;</a></span>extractByModulePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::extractByModulePath </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fullPathPatterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts model topology by module full path. </p>
<p>All modules whole getFullPath() matches one of the patterns in given string vector will get included. The patterns may contain wilcards in the same syntax as in ini files.</p>
<p>An example:</p>
<p><code>topo.extractByModulePath(cStringTokenizer("**.host[*] **.router*").asVector());</code> </p>
<div class="fragment"><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;{</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork</a>(selectByModulePath, (<span class="keywordtype">void</span> *)&amp;fullPathPatterns);</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a35c519b0b9a31e5b8053051ea16ae307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c519b0b9a31e5b8053051ea16ae307">&#9670;&nbsp;</a></span>extractByNedTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::extractByNedTypeName </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>nedTypeNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts model topology by the fully qualified NED type name of the modules. </p>
<p>All modules whose getNedTypeName() is listed in the given string vector will get included.</p>
<p>Note: If you have all class names as a single, space-separated string, you can use cStringTokenizer to turn it into a string vector:</p>
<p><code>topo.extractByNedTypeName(cStringTokenizer("some.package.Host other.package.Router").asVector());</code> </p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;{</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork</a>(selectByNedTypeName, (<span class="keywordtype">void</span> *)&amp;nedTypeNames);</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5f9999b154df2884dfd29da1b5f74ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f9999b154df2884dfd29da1b5f74ae">&#9670;&nbsp;</a></span>extractByParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::extractByParameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>paramValue</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts model topology by a module parameter. </p>
<p>All modules get included that have a parameter with the given name, and the parameter's <a class="el" href="classinet_1_1_topology.html#ac49be07cc21ff68bec558d787576a3a3" title="Produces a one-line description of the object&#39;s contents.">str()</a> method returns the paramValue string. If paramValue is nullptr, only the parameter's existence is checked but not its value. </p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;{</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keyword">struct </span>{</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">char</span> *name;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">char</span> *value;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    } data = {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        paramName, paramValue</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    };</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork</a>(selectByParameter, (<span class="keywordtype">void</span> *)&amp;data);</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4fe25ad92498a0990119c065012c7131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe25ad92498a0990119c065012c7131">&#9670;&nbsp;</a></span>extractByProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::extractByProperty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts model topology by a module property. </p>
<p>All modules get included that have a property with the given name and the given value (more precisely, the first value of its default key being the specified value). If value is nullptr, the property's value may be anything except "false" (i.e. the first value of the default key may not be "false").</p>
<p>For example, <code>topo.extractByProperty("networkNode");</code> would extract all modules that contain the <code>@networkNode</code> property, like the following one:</p>
<pre>
module X {
    @networkNode;
}
</pre> <div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;{</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keyword">struct </span>{</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">char</span> *name;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">char</span> *value;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    } data = {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        propertyName, value</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    };</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork</a>(selectByProperty, (<span class="keywordtype">void</span> *)&amp;data);</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_stp_tester.html#aba93e6670efb2e3be11714dc625fcd98">inet::StpTester::depthFirstSearch()</a>, <a class="el" href="classinet_1_1_network_configurator_base.html#a7b8bb336f49bf3c28b2babaca96adb72">inet::NetworkConfiguratorBase::extractTopology()</a>, <a class="el" href="classinet_1_1_l2_network_configurator.html#a88bf324c919d91ba75f4facdfad83630">inet::L2NetworkConfigurator::extractTopology()</a>, and <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a1f37759d507052aee49de5e18fd2564c">inet::L3NetworkConfiguratorBase::extractTopology()</a>.</p>

</div>
</div>
<a id="a0d7b227585c394dd6b195c8e7f0f129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7b227585c394dd6b195c8e7f0f129f">&#9670;&nbsp;</a></span>extractFromNetwork() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::extractFromNetwork </td>
          <td>(</td>
          <td class="paramtype">bool(*)(cModule *, void *)&#160;</td>
          <td class="paramname"><em>selfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts model topology by a user-defined criteria. </p>
<p>Includes into the graph modules for which the passed selfunc() returns nonzero. The userdata parameter may take any value you like, and it is passed back to selfunc() in its second argument. </p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;{</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a4807e7915fbc2b1c8ecf0d217088399a">clear</a>();</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160; </div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">// Loop through all modules and find those that satisfy the criteria</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="keywordtype">int</span> networkId = 0;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> modId = 0; modId &lt;= getSimulation()-&gt;getLastComponentId(); modId++) {</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        cModule *module = getSimulation()-&gt;getModule(modId);</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keywordflow">if</span> (module &amp;&amp; predicate(module, data)) {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            Node *node = <a class="code" href="classinet_1_1_topology.html#a4942b49db44f2ee0038b15b087c7bad0">createNode</a>(module);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            node-&gt;setNetworkId(++networkId);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.push_back(node);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        }</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    }</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160; </div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">// Discover out neighbors too.</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>) {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        <span class="comment">// Loop through all its gates and find those which come</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="comment">// from or go to modules included in the topology.</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160; </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        Node *node = elem;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        cModule *<a class="code" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a> = getSimulation()-&gt;getModule(node-&gt;moduleId);</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160; </div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="keywordflow">for</span> (cModule::GateIterator i(<a class="code" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a>); !i.end(); i++) {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            cGate *gate = *i;</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            <span class="keywordflow">if</span> (gate-&gt;getType() != cGate::OUTPUT)</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160; </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="comment">// follow path</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            cGate *srcGate = gate;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            <span class="keywordflow">do</span> {</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                gate = gate-&gt;getNextGate();</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            } <span class="keywordflow">while</span> (gate &amp;&amp; !predicate(gate-&gt;getOwnerModule(), data));</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160; </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            <span class="comment">// if we arrived at a module in the topology, record it.</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            <span class="keywordflow">if</span> (gate) {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                Link *link = <a class="code" href="classinet_1_1_topology.html#a76bf87fee674ecd44885b1c53074579f">createLink</a>();</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                link-&gt;srcNode = node;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                link-&gt;srcGateId = srcGate-&gt;getId();</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                link-&gt;destNode = <a class="code" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">getNodeFor</a>(gate-&gt;getOwnerModule());</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                link-&gt;destGateId = gate-&gt;getId();</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                node-&gt;outLinks.push_back(link);</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;            }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    }</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160; </div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="comment">// fill inLinks vectors</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>) {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; _l : elem-&gt;outLinks) {</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            Topology::Link *link = _l;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            link-&gt;destNode-&gt;inLinks.push_back(link);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        }</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    }</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160; </div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>)</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <a class="code" href="classinet_1_1_topology.html#a473823ca721e0c7d833aa7464e0e3fa9">findNetworks</a>(elem);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#aff007f5cffa94466a5aa65a1fd9441ec">extractByModulePath()</a>, <a class="el" href="classinet_1_1_topology.html#a35c519b0b9a31e5b8053051ea16ae307">extractByNedTypeName()</a>, <a class="el" href="classinet_1_1_topology.html#ad5f9999b154df2884dfd29da1b5f74ae">extractByParameter()</a>, <a class="el" href="classinet_1_1_topology.html#a4fe25ad92498a0990119c065012c7131">extractByProperty()</a>, and <a class="el" href="classinet_1_1_topology.html#a4c6d3a31e341322df26afc0352542a73">extractFromNetwork()</a>.</p>

</div>
</div>
<a id="a4c6d3a31e341322df26afc0352542a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6d3a31e341322df26afc0352542a73">&#9670;&nbsp;</a></span>extractFromNetwork() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::extractFromNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_predicate.html">Predicate</a> *&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type safe, object-oriented equivalent of extractFromNetwork(selfunc, userdata). </p>
<div class="fragment"><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;{</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <a class="code" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork</a>(selectByPredicate, (<span class="keywordtype">void</span> *)predicate);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a473823ca721e0c7d833aa7464e0e3fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473823ca721e0c7d833aa7464e0e3fa9">&#9670;&nbsp;</a></span>findNetworks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::findNetworks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;{</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="keywordflow">if</span> (node-&gt;isVisited())</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160; </div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    cModule *<a class="code" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a> = getSimulation()-&gt;getModule(node-&gt;moduleId);</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a>)</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160; </div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="keywordflow">for</span> (cModule::GateIterator i(<a class="code" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a>); !i.end(); i++) {</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        cGate *gate = *i;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="keywordflow">if</span> (gate-&gt;getType() != cGate::OUTPUT)</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160; </div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="comment">// follow path</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        <span class="keywordflow">do</span> {</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            gate = gate-&gt;getNextGate();</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        } <span class="keywordflow">while</span> (gate &amp;&amp; !gate-&gt;getOwnerModule());</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160; </div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        <span class="comment">// if we arrived at a module in the topology, record it.</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        <span class="keywordflow">if</span> (gate) {</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;            node-&gt;setVisited(<span class="keyword">true</span>);</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            Node *nextNode = <a class="code" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">getNodeFor</a>(gate-&gt;getOwnerModule());</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            <span class="keywordflow">if</span> (nextNode) {</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;                <span class="keywordflow">if</span> (!nextNode-&gt;isVisited()) {</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                    nextNode-&gt;setNetworkId(node-&gt;getNetworkId());</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                    <a class="code" href="classinet_1_1_topology.html#a473823ca721e0c7d833aa7464e0e3fa9">findNetworks</a>(nextNode);</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                }</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            }</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        }</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    }</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork()</a>.</p>

</div>
</div>
<a id="aaaa5ab2e1148005506e91facd800ef68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa5ab2e1148005506e91facd800ef68">&#9670;&nbsp;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1_topology_1_1_node.html">Topology::Node</a> * inet::Topology::getNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to the ith node in the graph. </p>
<p><a class="el" href="classinet_1_1_topology_1_1_node.html" title="Supporting class for Topology, represents a node in the graph.">Node</a>'s methods can be used to further examine the node's connectivity, etc. </p>
<div class="fragment"><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;{</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= (<span class="keywordtype">int</span>)<a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.size())</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">throw</span> cRuntimeError(<span class="keyword">this</span>, <span class="stringliteral">&quot;invalid node index %d&quot;</span>, i);</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>[i];</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#ae65415169bbe2f92e8c934579a2b9d4b">inet::GateScheduleConfiguratorBase::addDevices()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#a09e3c41b831a17d947fe477ad4ae4a70">inet::GateScheduleConfiguratorBase::addFlows()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#aef0ed7ac8adf63bf362055c8e5107b6f">inet::GateScheduleConfiguratorBase::addPorts()</a>, <a class="el" href="classinet_1_1_next_hop_network_configurator.html#a092f0098e1756298a5342a3d8dc4045f">inet::NextHopNetworkConfigurator::addStaticRoutes()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#af09601980aa83478c7c7416c572be249">inet::Ipv4NetworkConfigurator::addStaticRoutes()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#a7dfb7e91940a7018cce431f2ce3cf132">inet::GateScheduleConfiguratorBase::addSwitches()</a>, <a class="el" href="classinet_1_1_mac_forwarding_table_configurator.html#a48c4dca2e12780834e292f1a8f4dda4e">inet::MacForwardingTableConfigurator::computeMacForwardingTables()</a>, <a class="el" href="classinet_1_1_failure_protection_configurator.html#a7a52a479f75c57ce3e2e39d61d7e2a37">inet::FailureProtectionConfigurator::computeStream()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#a17bd369f0aa6f9272e17056123516ce5">inet::StreamRedundancyConfigurator::computeStreamEncodings()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#afdb6e1ec376093e9d0640c0c199acc34">inet::StreamRedundancyConfigurator::computeStreamPolicyConfigurations()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#a4d3321e7d36d345f3a4f46a760e3f3a3">inet::StreamRedundancyConfigurator::computeStreamSendersAndReceivers()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#ac2a11cec5aacd0c484bd628f44798e80">inet::Ipv4NetworkConfigurator::configureAllInterfaces()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a6c7803e96eee54c38b3b6c0ee27f7334">inet::Ipv4NetworkConfigurator::configureAllRoutingTables()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#a40afd7db18f1ed9b6d80c662b52db248">inet::GateScheduleConfiguratorBase::configureGateScheduling()</a>, <a class="el" href="classinet_1_1_l2_network_configurator.html#a033ff455a6c0ffa54e1ce03d48743360">inet::L2NetworkConfigurator::configureInterface()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#aebca491ea22e98b2ead43c5b93fc0636">inet::Ipv4NetworkConfigurator::configureRoutingTable()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#ae151a200cf95fe0a1818a25093546a1a">inet::StreamRedundancyConfigurator::configureStreams()</a>, <a class="el" href="classinet_1_1_stp_tester.html#aba93e6670efb2e3be11714dc625fcd98">inet::StpTester::depthFirstSearch()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a493ac55eb1caa587ec698a6e4972efc9">inet::Ipv4NetworkConfigurator::dumpConfig()</a>, <a class="el" href="classinet_1_1_next_hop_network_configurator.html#a1e130f05b568dc296a044c605331cc83">inet::NextHopNetworkConfigurator::dumpRoutes()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#aa6d6b2bfb76ff54e9d5ee1680ccfd534">inet::Ipv4NetworkConfigurator::dumpRoutes()</a>, <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a4c28097ad38c39473dd84544353a71b8">inet::L3NetworkConfiguratorBase::dumpTopology()</a>, <a class="el" href="classinet_1_1_mac_forwarding_table_configurator.html#a7614dd25a13d0a89b7eaf219df65f5f6">inet::MacForwardingTableConfigurator::extendConfiguration()</a>, <a class="el" href="classinet_1_1_network_configurator_base.html#a7b8bb336f49bf3c28b2babaca96adb72">inet::NetworkConfiguratorBase::extractTopology()</a>, <a class="el" href="classinet_1_1_l2_network_configurator.html#a88bf324c919d91ba75f4facdfad83630">inet::L2NetworkConfigurator::extractTopology()</a>, <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a1f37759d507052aee49de5e18fd2564c">inet::L3NetworkConfiguratorBase::extractTopology()</a>, <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a9b312856a2f8007d249a7c6a62c98dcd">inet::L3NetworkConfiguratorBase::extractWirelessNeighbors()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a2b02c7acadd47413bdd021e61d868fd1">inet::Ipv4NetworkConfigurator::readManualMulticastRouteConfiguration()</a>, and <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a894ec2e45eaa9fdd58ee653bb9b990ed">inet::Ipv4NetworkConfigurator::readManualRouteConfiguration()</a>.</p>

</div>
</div>
<a id="ad83dbad494392c1a5e63e43577198bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83dbad494392c1a5e63e43577198bdb">&#9670;&nbsp;</a></span>getNodeFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1_topology_1_1_node.html">Topology::Node</a> * inet::Topology::getNodeFor </td>
          <td>(</td>
          <td class="paramtype">cModule *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the graph node which corresponds to the given module in the network. </p>
<p>If no graph node corresponds to the module, the method returns nullptr. This method assumes that the topology corresponds to the network, that is, it was probably created with one of the extract...() functions. </p>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;{</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="comment">// binary search because nodes[] is ordered by module ID</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    Node tmpNode(<a class="code" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a>-&gt;getId());</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keyword">auto</span> it = std::lower_bound(<a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.begin(), <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.end(), &amp;tmpNode, <a class="code" href="classinet_1_1_topology.html#af9e3dddf75691776de3a8641ad48bd22">lessByModuleId</a>);</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="comment">// TODO this does not compile with VC9 (VC10 is OK): auto it = std::lower_bound(nodes.begin(), nodes.end(), mod-&gt;getId(), isModuleIdLess);</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">return</span> it == <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.end() || (*it)-&gt;moduleId != <a class="code" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a>-&gt;getId() ? nullptr : *it;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#a4bb3ef43d4dfcfe7a8f4b9dc6e63e498">addLink()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#aef0ed7ac8adf63bf362055c8e5107b6f">inet::GateScheduleConfiguratorBase::addPorts()</a>, <a class="el" href="classinet_1_1_eager_gate_schedule_configurator.html#ae44690ac08adc4a24b08828adda38851">inet::EagerGateScheduleConfigurator::computeStartOffsetForPathFragments()</a>, <a class="el" href="classinet_1_1_failure_protection_configurator.html#a7a52a479f75c57ce3e2e39d61d7e2a37">inet::FailureProtectionConfigurator::computeStream()</a>, <a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork()</a>, <a class="el" href="classinet_1_1_topology.html#a473823ca721e0c7d833aa7464e0e3fa9">findNetworks()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#a99a6c6746a245f06cf5d593e6a4ec9d1">inet::StreamRedundancyConfigurator::getPathFragments()</a>, and <a class="el" href="classinet_1_1_mac_forwarding_table_configurator.html#a6130d493b136c5ce78f52e1af1ec454e">inet::MacForwardingTableConfigurator::receiveSignal()</a>.</p>

</div>
</div>
<a id="aa260c302d257232f55485668b0d184a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa260c302d257232f55485668b0d184a0">&#9670;&nbsp;</a></span>getNumNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int inet::Topology::getNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes in the graph. </p>
<div class="fragment"><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.size(); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#ae65415169bbe2f92e8c934579a2b9d4b">inet::GateScheduleConfiguratorBase::addDevices()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#a09e3c41b831a17d947fe477ad4ae4a70">inet::GateScheduleConfiguratorBase::addFlows()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#aef0ed7ac8adf63bf362055c8e5107b6f">inet::GateScheduleConfiguratorBase::addPorts()</a>, <a class="el" href="classinet_1_1_next_hop_network_configurator.html#a092f0098e1756298a5342a3d8dc4045f">inet::NextHopNetworkConfigurator::addStaticRoutes()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#af09601980aa83478c7c7416c572be249">inet::Ipv4NetworkConfigurator::addStaticRoutes()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#a7dfb7e91940a7018cce431f2ce3cf132">inet::GateScheduleConfiguratorBase::addSwitches()</a>, <a class="el" href="classinet_1_1_mac_forwarding_table_configurator.html#a48c4dca2e12780834e292f1a8f4dda4e">inet::MacForwardingTableConfigurator::computeMacForwardingTables()</a>, <a class="el" href="classinet_1_1_failure_protection_configurator.html#a7a52a479f75c57ce3e2e39d61d7e2a37">inet::FailureProtectionConfigurator::computeStream()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#a17bd369f0aa6f9272e17056123516ce5">inet::StreamRedundancyConfigurator::computeStreamEncodings()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#afdb6e1ec376093e9d0640c0c199acc34">inet::StreamRedundancyConfigurator::computeStreamPolicyConfigurations()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#a4d3321e7d36d345f3a4f46a760e3f3a3">inet::StreamRedundancyConfigurator::computeStreamSendersAndReceivers()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#ac2a11cec5aacd0c484bd628f44798e80">inet::Ipv4NetworkConfigurator::configureAllInterfaces()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a6c7803e96eee54c38b3b6c0ee27f7334">inet::Ipv4NetworkConfigurator::configureAllRoutingTables()</a>, <a class="el" href="classinet_1_1_gate_schedule_configurator_base.html#a40afd7db18f1ed9b6d80c662b52db248">inet::GateScheduleConfiguratorBase::configureGateScheduling()</a>, <a class="el" href="classinet_1_1_l2_network_configurator.html#a033ff455a6c0ffa54e1ce03d48743360">inet::L2NetworkConfigurator::configureInterface()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#aebca491ea22e98b2ead43c5b93fc0636">inet::Ipv4NetworkConfigurator::configureRoutingTable()</a>, <a class="el" href="classinet_1_1_stream_redundancy_configurator.html#ae151a200cf95fe0a1818a25093546a1a">inet::StreamRedundancyConfigurator::configureStreams()</a>, <a class="el" href="classinet_1_1_stp_tester.html#aba93e6670efb2e3be11714dc625fcd98">inet::StpTester::depthFirstSearch()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a493ac55eb1caa587ec698a6e4972efc9">inet::Ipv4NetworkConfigurator::dumpConfig()</a>, <a class="el" href="classinet_1_1_next_hop_network_configurator.html#a1e130f05b568dc296a044c605331cc83">inet::NextHopNetworkConfigurator::dumpRoutes()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#aa6d6b2bfb76ff54e9d5ee1680ccfd534">inet::Ipv4NetworkConfigurator::dumpRoutes()</a>, <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a4c28097ad38c39473dd84544353a71b8">inet::L3NetworkConfiguratorBase::dumpTopology()</a>, <a class="el" href="classinet_1_1_l2_network_configurator.html#a82c89cd3b3a041369e765243b65c9d89">inet::L2NetworkConfigurator::ensureConfigurationComputed()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a4e3a75ec32a9078c8ec2c5f82627bfd2">inet::Ipv4NetworkConfigurator::ensureConfigurationComputed()</a>, <a class="el" href="classinet_1_1_mac_forwarding_table_configurator.html#a7614dd25a13d0a89b7eaf219df65f5f6">inet::MacForwardingTableConfigurator::extendConfiguration()</a>, <a class="el" href="classinet_1_1_network_configurator_base.html#a7b8bb336f49bf3c28b2babaca96adb72">inet::NetworkConfiguratorBase::extractTopology()</a>, <a class="el" href="classinet_1_1_l2_network_configurator.html#a88bf324c919d91ba75f4facdfad83630">inet::L2NetworkConfigurator::extractTopology()</a>, <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a1f37759d507052aee49de5e18fd2564c">inet::L3NetworkConfiguratorBase::extractTopology()</a>, <a class="el" href="classinet_1_1_l3_network_configurator_base.html#a9b312856a2f8007d249a7c6a62c98dcd">inet::L3NetworkConfiguratorBase::extractWirelessNeighbors()</a>, <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a2b02c7acadd47413bdd021e61d868fd1">inet::Ipv4NetworkConfigurator::readManualMulticastRouteConfiguration()</a>, and <a class="el" href="classinet_1_1_ipv4_network_configurator.html#a894ec2e45eaa9fdd58ee653bb9b990ed">inet::Ipv4NetworkConfigurator::readManualRouteConfiguration()</a>.</p>

</div>
</div>
<a id="a7255ea09bbd2dfbf7368e592eb183741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7255ea09bbd2dfbf7368e592eb183741">&#9670;&nbsp;</a></span>isModuleIdLess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool inet::Topology::isModuleIdLess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>moduleId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;{ <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)a-&gt;moduleId &lt; (<span class="keywordtype">unsigned</span> int)moduleId; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af9e3dddf75691776de3a8641ad48bd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e3dddf75691776de3a8641ad48bd22">&#9670;&nbsp;</a></span>lessByModuleId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool inet::Topology::lessByModuleId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;{ <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)a-&gt;moduleId &lt; (<span class="keywordtype">unsigned</span> int)<a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>-&gt;moduleId; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#aa3d1c482760c38b804098416d2752719">addNode()</a>, and <a class="el" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">getNodeFor()</a>.</p>

</div>
</div>
<a id="a5d911ba65804d10b0f89284f4835c7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d911ba65804d10b0f89284f4835c7c7">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1_topology.html">Topology</a> &amp; inet::Topology::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinet_1_1_topology.html">Topology</a> &amp;&#160;</td>
          <td class="paramname"><em>topo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>The name member is not copied; see cNamedObject's <a class="el" href="classinet_1_1_topology.html#a5d911ba65804d10b0f89284f4835c7c7" title="Assignment operator.">operator=()</a> for more details. </p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;{</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">throw</span> cRuntimeError(<span class="keyword">this</span>, <span class="stringliteral">&quot;operator= not implemented yet&quot;</span>);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae14dce65d390c3868464c41e2f45740d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14dce65d390c3868464c41e2f45740d">&#9670;&nbsp;</a></span>parsimPack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::parsimPack </td>
          <td>(</td>
          <td class="paramtype">cCommBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the object into an MPI send buffer. </p>
<p>Used by the simulation kernel for parallel execution. See cObject for more details. </p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;{</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">throw</span> cRuntimeError(<span class="keyword">this</span>, <span class="stringliteral">&quot;parsimPack() not implemented&quot;</span>);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a05ebcc6fd7722ceab87bbd129cc16703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ebcc6fd7722ceab87bbd129cc16703">&#9670;&nbsp;</a></span>parsimUnpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::parsimUnpack </td>
          <td>(</td>
          <td class="paramtype">cCommBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes the object from an MPI receive buffer Used by the simulation kernel for parallel execution. </p>
<p>See cObject for more details. </p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;{</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">throw</span> cRuntimeError(<span class="keyword">this</span>, <span class="stringliteral">&quot;parsimUnpack() not implemented&quot;</span>);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac49be07cc21ff68bec558d787576a3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49be07cc21ff68bec558d787576a3a3">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string inet::Topology::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a one-line description of the object's contents. </p>
<p>See cObject for more details. </p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    std::stringstream out;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    out &lt;&lt; <span class="stringliteral">&quot;n=&quot;</span> &lt;&lt; <a class="code" href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">nodes</a>.size();</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> out.str();</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abc51993c1e0dd6c3d62f9f43a089e00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc51993c1e0dd6c3d62f9f43a089e00e">&#9670;&nbsp;</a></span>unlinkFromDestNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::unlinkFromDestNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;{</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    std::vector&lt;Link *&gt;&amp; destInLinks = link-&gt;destNode-&gt;inLinks;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keyword">auto</span> it = <a class="code" href="namespaceinet.html#a5c4aab0dc099233ae85fac1980ea909a">find</a>(destInLinks, link);</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    ASSERT(it != destInLinks.end());</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    destInLinks.erase(it);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#a01f46fb3abb301aba36ccdede6221b21">addLink()</a>, <a class="el" href="classinet_1_1_topology.html#ab57fd36fa6fbe8f2ace22894fc583fb1">deleteLink()</a>, and <a class="el" href="classinet_1_1_topology.html#a47ea22a249a17f6283e65220193090a0">deleteNode()</a>.</p>

</div>
</div>
<a id="a5c84757f6a56ba7c00be8d4d7ca25bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c84757f6a56ba7c00be8d4d7ca25bc7">&#9670;&nbsp;</a></span>unlinkFromSourceNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::Topology::unlinkFromSourceNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinet_1_1_topology_1_1_link.html">Link</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;{</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    std::vector&lt;Link *&gt;&amp; srcOutLinks = link-&gt;srcNode-&gt;outLinks;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keyword">auto</span> it = <a class="code" href="namespaceinet.html#a5c4aab0dc099233ae85fac1980ea909a">find</a>(srcOutLinks, link);</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    ASSERT(it != srcOutLinks.end());</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    srcOutLinks.erase(it);</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#a01f46fb3abb301aba36ccdede6221b21">addLink()</a>, <a class="el" href="classinet_1_1_topology.html#ab57fd36fa6fbe8f2ace22894fc583fb1">deleteLink()</a>, and <a class="el" href="classinet_1_1_topology.html#a47ea22a249a17f6283e65220193090a0">deleteNode()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aec5f18015f721d0343ba4dfffcf728ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5f18015f721d0343ba4dfffcf728ed">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classinet_1_1_topology_1_1_node.html">Node</a> *&gt; inet::Topology::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="classinet_1_1_topology.html#aa3d1c482760c38b804098416d2752719">addNode()</a>, <a class="el" href="classinet_1_1_topology.html#a8ee4d5d41ecae9a2a3e7672d4aa9f598">calculateUnweightedSingleShortestPathsTo()</a>, <a class="el" href="classinet_1_1_topology.html#a9680f0f189bfc1aa59c9c06746507a73">calculateWeightedSingleShortestPathsTo()</a>, <a class="el" href="classinet_1_1_topology.html#a4807e7915fbc2b1c8ecf0d217088399a">clear()</a>, <a class="el" href="classinet_1_1_topology.html#a47ea22a249a17f6283e65220193090a0">deleteNode()</a>, <a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">extractFromNetwork()</a>, <a class="el" href="classinet_1_1_topology.html#aaaa5ab2e1148005506e91facd800ef68">getNode()</a>, <a class="el" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">getNodeFor()</a>, and <a class="el" href="classinet_1_1_topology.html#ac49be07cc21ff68bec558d787576a3a3">str()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_topology_8h.html">Topology.h</a></li>
<li><a class="el" href="_topology_8cc.html">Topology.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceinet_1_1math_html_a48eb5699c67c54008123531fa3267c30"><div class="ttname"><a href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">inet::math::mod</a></div><div class="ttdeci">double mod(double dividend, double divisor)</div><div class="ttdoc">Returns the rest of a whole-numbered division.</div><div class="ttdef"><b>Definition:</b> INETMath.h:96</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_af9e3dddf75691776de3a8641ad48bd22"><div class="ttname"><a href="classinet_1_1_topology.html#af9e3dddf75691776de3a8641ad48bd22">inet::Topology::lessByModuleId</a></div><div class="ttdeci">static bool lessByModuleId(Node *a, Node *b)</div><div class="ttdef"><b>Definition:</b> Topology.h:330</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_a76bf87fee674ecd44885b1c53074579f"><div class="ttname"><a href="classinet_1_1_topology.html#a76bf87fee674ecd44885b1c53074579f">inet::Topology::createLink</a></div><div class="ttdeci">virtual Link * createLink()</div><div class="ttdoc">Link factory.</div><div class="ttdef"><b>Definition:</b> Topology.h:565</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_a96c1eb8c582a690828e2cd23eca458aa"><div class="ttname"><a href="classinet_1_1_topology.html#a96c1eb8c582a690828e2cd23eca458aa">inet::Topology::Topology</a></div><div class="ttdeci">Topology(const char *name=nullptr)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> Topology.cc:42</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_abc51993c1e0dd6c3d62f9f43a089e00e"><div class="ttname"><a href="classinet_1_1_topology.html#abc51993c1e0dd6c3d62f9f43a089e00e">inet::Topology::unlinkFromDestNode</a></div><div class="ttdeci">void unlinkFromDestNode(Link *link)</div><div class="ttdef"><b>Definition:</b> Topology.cc:340</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_ad83dbad494392c1a5e63e43577198bdb"><div class="ttname"><a href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">inet::Topology::getNodeFor</a></div><div class="ttdeci">Node * getNodeFor(cModule *mod) const</div><div class="ttdoc">Returns the graph node which corresponds to the given module in the network.</div><div class="ttdef"><b>Definition:</b> Topology.cc:355</div></div>
<div class="ttc" id="anamespaceinet_html_a0d52548b78348f043858dcb54d8c1e11"><div class="ttname"><a href="namespaceinet.html#a0d52548b78348f043858dcb54d8c1e11">inet::remove</a></div><div class="ttdeci">void remove(std::vector&lt; T &gt; &amp;v, const Tk &amp;a)</div><div class="ttdef"><b>Definition:</b> stlutils.h:107</div></div>
<div class="ttc" id="anamespaceinet_html_a5c4aab0dc099233ae85fac1980ea909a"><div class="ttname"><a href="namespaceinet.html#a5c4aab0dc099233ae85fac1980ea909a">inet::find</a></div><div class="ttdeci">std::vector&lt; T &gt;::iterator find(std::vector&lt; T &gt; &amp;v, const Tk &amp;a)</div><div class="ttdef"><b>Definition:</b> stlutils.h:44</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_a4807e7915fbc2b1c8ecf0d217088399a"><div class="ttname"><a href="classinet_1_1_topology.html#a4807e7915fbc2b1c8ecf0d217088399a">inet::Topology::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Deletes the topology stored in the object.</div><div class="ttdef"><b>Definition:</b> Topology.cc:78</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_aec5f18015f721d0343ba4dfffcf728ed"><div class="ttname"><a href="classinet_1_1_topology.html#aec5f18015f721d0343ba4dfffcf728ed">inet::Topology::nodes</a></div><div class="ttdeci">std::vector&lt; Node * &gt; nodes</div><div class="ttdef"><b>Definition:</b> Topology.h:327</div></div>
<div class="ttc" id="anamespaceinet_html_ab4f59162a287d7a85fde3ca104470c6e"><div class="ttname"><a href="namespaceinet.html#ab4f59162a287d7a85fde3ca104470c6e">inet::contains</a></div><div class="ttdeci">bool contains(const std::vector&lt; T &gt; &amp;v, const Tk &amp;a)</div><div class="ttdef"><b>Definition:</b> stlutils.h:65</div></div>
<div class="ttc" id="a_topology_8h_html_a956e2723d559858d08644ac99146e910"><div class="ttname"><a href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a></div><div class="ttdeci">#define INFINITY</div><div class="ttdef"><b>Definition:</b> Topology.h:20</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_a5c84757f6a56ba7c00be8d4d7ca25bc7"><div class="ttname"><a href="classinet_1_1_topology.html#a5c84757f6a56ba7c00be8d4d7ca25bc7">inet::Topology::unlinkFromSourceNode</a></div><div class="ttdeci">void unlinkFromSourceNode(Link *link)</div><div class="ttdef"><b>Definition:</b> Topology.cc:332</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_a473823ca721e0c7d833aa7464e0e3fa9"><div class="ttname"><a href="classinet_1_1_topology.html#a473823ca721e0c7d833aa7464e0e3fa9">inet::Topology::findNetworks</a></div><div class="ttdeci">void findNetworks(Node *)</div><div class="ttdef"><b>Definition:</b> Topology.cc:469</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1values_html_a02f32b4417da580f5e348f2c3cfb40a7"><div class="ttname"><a href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">inet::units::values::b</a></div><div class="ttdeci">value&lt; int64_t, units::b &gt; b</div><div class="ttdef"><b>Definition:</b> Units.h:1241</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_a4942b49db44f2ee0038b15b087c7bad0"><div class="ttname"><a href="classinet_1_1_topology.html#a4942b49db44f2ee0038b15b087c7bad0">inet::Topology::createNode</a></div><div class="ttdeci">virtual Node * createNode(cModule *module)</div><div class="ttdoc">Node factory.</div><div class="ttdef"><b>Definition:</b> Topology.h:560</div></div>
<div class="ttc" id="aclassinet_1_1_topology_html_a0d7b227585c394dd6b195c8e7f0f129f"><div class="ttname"><a href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">inet::Topology::extractFromNetwork</a></div><div class="ttdeci">void extractFromNetwork(bool(*selfunc)(cModule *, void *), void *userdata=nullptr)</div><div class="ttdoc">Extracts model topology by a user-defined criteria.</div><div class="ttdef"><b>Definition:</b> Topology.cc:184</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinet.html">inet</a></li><li class="navelem"><a class="el" href="classinet_1_1_topology.html">Topology</a></li>
    <li class="footer">Generated on Sun Apr 10 2022 21:00:28 for INET Framework for OMNeT++/OMNEST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
