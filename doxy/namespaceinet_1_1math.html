<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INET Framework for OMNeT++/OMNEST: inet::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="opp.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">INET Framework for OMNeT++/OMNEST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceinet_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">inet::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support functions for mathematical operations.  
<a href="namespaceinet_1_1math.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinet_1_1math_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_added_function.html">AddedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_approximated_function.html">ApproximatedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the values and partitioning of a multidimensional function along one of the dimensions.  <a href="classinet_1_1math_1_1_approximated_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_average_interpolator.html">AverageInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_bilinear_function.html">BilinearFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear in two dimensions and constant in the others.  <a href="classinet_1_1math_1_1_bilinear_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_boxcar1_d_function.html">Boxcar1DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some constant value r between lower and upper and zero otherwise.  <a href="classinet_1_1math_1_1_boxcar1_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_boxcar2_d_function.html">Boxcar2DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some constant value r between (lowerX, lowerY) and (upperX, upperY) and zero otherwise.  <a href="classinet_1_1math_1_1_boxcar2_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_closer_interpolator.html">CloserInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_combined2_d_function.html">Combined2DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines 2 one-dimensional functions into a two-dimensional function.  <a href="classinet_1_1math_1_1_combined2_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_constant_function.html">ConstantFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_constant_interpolator_base.html">ConstantInterpolatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_divided_function.html">DividedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_domain.html">Domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the domain of a mathematical function.  <a href="classinet_1_1math_1_1_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_domain_limited_function.html">DomainLimitedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits the domain of a multidimensional function.  <a href="classinet_1_1math_1_1_domain_limited_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_domain_modulated2_d_function.html">DomainModulated2DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulates the domain of a two-dimensional function with the values of a one-dimensional function.  <a href="classinet_1_1math_1_1_domain_modulated2_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_domain_shifted_function.html">DomainShiftedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the domain of a multidimensional function.  <a href="classinet_1_1math_1_1_domain_shifted_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_either_interpolator.html">EitherInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation that can only be used if y1 == y2.  <a href="classinet_1_1math_1_1_either_interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_extruded2_d_function.html">Extruded2DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrudes a one-dimensional function into a two-dimensional function.  <a href="classinet_1_1math_1_1_extruded2_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_base.html">FunctionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful base class for most <a class="el" href="classinet_1_1math_1_1_i_function.html" title="This interface represents a mathematical function from domain D to range R.">IFunction</a> implementations with some default behavior.  <a href="classinet_1_1math_1_1_function_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_function_checker.html">FunctionChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that partitioning on a domain is correct in the sense that the original function and the function over the partition return the same values at the corners and center of the subdomain.  <a href="classinet_1_1math_1_1_function_checker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_gauss_function.html">GaussFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The one-dimensional Gauss function.  <a href="classinet_1_1math_1_1_gauss_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents a mathematical function from domain D to range R.  <a href="classinet_1_1math_1_1_i_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_i_interpolator.html">IInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents interpolation of values (y) between two points x1 and x2.  <a href="classinet_1_1math_1_1_i_interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_integrated_function.html">IntegratedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_integrated_function_3_01_r_00_01_domain_3_01_x_00_01_y_01_4_00_01_d_i_m_s_4b6d079b8ed0b5d70f4a7eb429f42394.html">IntegratedFunction&lt; R, Domain&lt; X, Y &gt;, DIMS, RI, Domain&lt; X &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a multidimensional function in one of the dimensions producing a function with one less number of dimensions.  <a href="classinet_1_1math_1_1_integrated_function_3_01_r_00_01_domain_3_01_x_00_01_y_01_4_00_01_d_i_m_s_4b6d079b8ed0b5d70f4a7eb429f42394.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_interpolated1_d_function.html">Interpolated1DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-dimensional interpolated (e.g.  <a href="classinet_1_1math_1_1_interpolated1_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_interpolator_base.html">InterpolatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional interval (cuboid), given by its two opposite corners.  <a href="classinet_1_1math_1_1_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_left_currying_function.html">LeftCurryingFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes the parameters of a function from the left.  <a href="classinet_1_1math_1_1_left_currying_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_left_interpolator.html">LeftInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_lineardb_interpolator.html">LineardbInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_linear_interpolator.html">LinearInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_maximum_interpolator.html">MaximumInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_memoized_function.html">MemoizedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the values of a multidimensional function outside the given domain to 0.  <a href="classinet_1_1math_1_1_memoized_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_minimum_interpolator.html">MinimumInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_multiplied_function.html">MultipliedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_periodically_interpolated1_d_function.html">PeriodicallyInterpolated1DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-dimensional interpolated (e.g.  <a href="classinet_1_1math_1_1_periodically_interpolated1_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_periodically_interpolated2_d_function.html">PeriodicallyInterpolated2DFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional point.  <a href="classinet_1_1math_1_1_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_rasterized2_d_function.html">Rasterized2DFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rasterizes a function into a grid where each cell is a constant value with the mean of the original function.  <a href="classinet_1_1math_1_1_rasterized2_d_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_right_currying_function.html">RightCurryingFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes the parameters of a function from the right.  <a href="classinet_1_1math_1_1_right_currying_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_right_interpolator.html">RightInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_sawtooth_function.html">SawtoothFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-dimensional periodic function with a sawtooth shape.  <a href="classinet_1_1math_1_1_sawtooth_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_subtracted_function.html">SubtractedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_summed_function.html">SummedFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_unilinear_function.html">UnilinearFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear in one dimension and constant in the others.  <a href="classinet_1_1math_1_1_unilinear_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html">UnireciprocalFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reciprocal in a given dimension and constant in the others.  <a href="classinet_1_1math_1_1_unireciprocal_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48eb5699c67c54008123531fa3267c30"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">mod</a> (double dividend, double divisor)</td></tr>
<tr class="memdesc:a48eb5699c67c54008123531fa3267c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rest of a whole-numbered division.  <a href="namespaceinet_1_1math.html#a48eb5699c67c54008123531fa3267c30">More...</a><br /></td></tr>
<tr class="separator:a48eb5699c67c54008123531fa3267c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec61226382f9d47b30002d6dadc903e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a8ec61226382f9d47b30002d6dadc903e">div</a> (double dividend, double divisor)</td></tr>
<tr class="memdesc:a8ec61226382f9d47b30002d6dadc903e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of a whole-numbered division.  <a href="namespaceinet_1_1math.html#a8ec61226382f9d47b30002d6dadc903e">More...</a><br /></td></tr>
<tr class="separator:a8ec61226382f9d47b30002d6dadc903e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3769b32c794160d2565384dcdd1e47dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a3769b32c794160d2565384dcdd1e47dc">modulo</a> (double a, double n)</td></tr>
<tr class="memdesc:a3769b32c794160d2565384dcdd1e47dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remainder r on division of dividend a by divisor n, using floored division.  <a href="namespaceinet_1_1math.html#a3769b32c794160d2565384dcdd1e47dc">More...</a><br /></td></tr>
<tr class="separator:a3769b32c794160d2565384dcdd1e47dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838c5a6b516bfc8bfa4f582f26111f71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a838c5a6b516bfc8bfa4f582f26111f71">close</a> (double one, double two)</td></tr>
<tr class="memdesc:a838c5a6b516bfc8bfa4f582f26111f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two doubles are close enough to be declared equal.  <a href="namespaceinet_1_1math.html#a838c5a6b516bfc8bfa4f582f26111f71">More...</a><br /></td></tr>
<tr class="separator:a838c5a6b516bfc8bfa4f582f26111f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a7068f428a9c3a06527de64a7a403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a285a7068f428a9c3a06527de64a7a403">stepfunction</a> (double i)</td></tr>
<tr class="memdesc:a285a7068f428a9c3a06527de64a7a403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 0 if i is close to 0, 1 if i is positive and greater than epsilon, or -1 if it is negative and less than epsilon.  <a href="namespaceinet_1_1math.html#a285a7068f428a9c3a06527de64a7a403">More...</a><br /></td></tr>
<tr class="separator:a285a7068f428a9c3a06527de64a7a403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c102bc04fd5af5d170394d1651b4558"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a8c102bc04fd5af5d170394d1651b4558">step</a> (double a, double <a class="el" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</td></tr>
<tr class="separator:a8c102bc04fd5af5d170394d1651b4558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64f9f74bdc3d9579b6efcf3e90ea795"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ab64f9f74bdc3d9579b6efcf3e90ea795">clamp</a> (double v, double l, double u)</td></tr>
<tr class="separator:ab64f9f74bdc3d9579b6efcf3e90ea795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e7a5e30cf695dc74a2bbb5018d140e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a27e7a5e30cf695dc74a2bbb5018d140e">sign</a> (double v)</td></tr>
<tr class="memdesc:a27e7a5e30cf695dc74a2bbb5018d140e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the parameter is greater than zero, -1 if less than zero, 0 otherwise.  <a href="namespaceinet_1_1math.html#a27e7a5e30cf695dc74a2bbb5018d140e">More...</a><br /></td></tr>
<tr class="separator:a27e7a5e30cf695dc74a2bbb5018d140e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee34a2a42269e7ea8a7fa2e3da5debd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#aee34a2a42269e7ea8a7fa2e3da5debd6">round</a> (double d)</td></tr>
<tr class="memdesc:aee34a2a42269e7ea8a7fa2e3da5debd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer that corresponds to rounded double parameter.  <a href="namespaceinet_1_1math.html#aee34a2a42269e7ea8a7fa2e3da5debd6">More...</a><br /></td></tr>
<tr class="separator:aee34a2a42269e7ea8a7fa2e3da5debd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61500313b7dc4a2130ddc44a55a8058c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a61500313b7dc4a2130ddc44a55a8058c">floorToZero</a> (double d)</td></tr>
<tr class="memdesc:a61500313b7dc4a2130ddc44a55a8058c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards the fractional part of the parameter, e.g.  <a href="namespaceinet_1_1math.html#a61500313b7dc4a2130ddc44a55a8058c">More...</a><br /></td></tr>
<tr class="separator:a61500313b7dc4a2130ddc44a55a8058c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46417f0a1e03abab8b2d23eba8ee63d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a46417f0a1e03abab8b2d23eba8ee63d6">dB2fraction</a> (double dB)</td></tr>
<tr class="memdesc:a46417f0a1e03abab8b2d23eba8ee63d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dB value to fraction.  <a href="namespaceinet_1_1math.html#a46417f0a1e03abab8b2d23eba8ee63d6">More...</a><br /></td></tr>
<tr class="separator:a46417f0a1e03abab8b2d23eba8ee63d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979fd42fd8afd4174e8608891f670c62"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a979fd42fd8afd4174e8608891f670c62">fraction2dB</a> (double fraction)</td></tr>
<tr class="memdesc:a979fd42fd8afd4174e8608891f670c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a fraction value to dB.  <a href="namespaceinet_1_1math.html#a979fd42fd8afd4174e8608891f670c62">More...</a><br /></td></tr>
<tr class="separator:a979fd42fd8afd4174e8608891f670c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bd082504cd879d1aaeb7f55b9ced17"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ab1bd082504cd879d1aaeb7f55b9ced17">dBmW2mW</a> (double dBm)</td></tr>
<tr class="memdesc:ab1bd082504cd879d1aaeb7f55b9ced17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dBmW value to mW.  <a href="namespaceinet_1_1math.html#ab1bd082504cd879d1aaeb7f55b9ced17">More...</a><br /></td></tr>
<tr class="separator:ab1bd082504cd879d1aaeb7f55b9ced17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1885b885fdbadd7bd599451f5f2c07f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a1885b885fdbadd7bd599451f5f2c07f4">mW2dBmW</a> (double <a class="el" href="namespaceinet_1_1units_1_1values.html#aa333518de1a98ec95be125bf5be68310">mW</a>)</td></tr>
<tr class="memdesc:a1885b885fdbadd7bd599451f5f2c07f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a mW value to dBmW.  <a href="namespaceinet_1_1math.html#a1885b885fdbadd7bd599451f5f2c07f4">More...</a><br /></td></tr>
<tr class="separator:a1885b885fdbadd7bd599451f5f2c07f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5653a8e0cc6d926f2790f713c9619a31"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a5653a8e0cc6d926f2790f713c9619a31">dBmWpMHz2WpHz</a> (double dBmWpMHz)</td></tr>
<tr class="memdesc:a5653a8e0cc6d926f2790f713c9619a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a dBmW/MHz value into W/Hz.  <a href="namespaceinet_1_1math.html#a5653a8e0cc6d926f2790f713c9619a31">More...</a><br /></td></tr>
<tr class="separator:a5653a8e0cc6d926f2790f713c9619a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e96c7e11d61986c9f8ca9e78733087"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a31e96c7e11d61986c9f8ca9e78733087">wpHz2dBmWpMHz</a> (double wpHz)</td></tr>
<tr class="memdesc:a31e96c7e11d61986c9f8ca9e78733087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a W/Hz value to dBmW/MHz.  <a href="namespaceinet_1_1math.html#a31e96c7e11d61986c9f8ca9e78733087">More...</a><br /></td></tr>
<tr class="separator:a31e96c7e11d61986c9f8ca9e78733087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5930cf83a8b56c5bf1dc5f0a634d5f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ac5930cf83a8b56c5bf1dc5f0a634d5f1">deg2rad</a> (double <a class="el" href="namespaceinet_1_1units_1_1values.html#a13ba52b4bc6cac91d658f5c0a36f39af">deg</a>)</td></tr>
<tr class="memdesc:ac5930cf83a8b56c5bf1dc5f0a634d5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a degree value to radian.  <a href="namespaceinet_1_1math.html#ac5930cf83a8b56c5bf1dc5f0a634d5f1">More...</a><br /></td></tr>
<tr class="separator:ac5930cf83a8b56c5bf1dc5f0a634d5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd300616e9eef6a7c35c4687ed7e479"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a9bd300616e9eef6a7c35c4687ed7e479">rad2deg</a> (double <a class="el" href="namespaceinet_1_1units_1_1values.html#a83a29e899a7f7807fff9e4659a34b10a">rad</a>)</td></tr>
<tr class="memdesc:a9bd300616e9eef6a7c35c4687ed7e479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a radian value to degree.  <a href="namespaceinet_1_1math.html#a9bd300616e9eef6a7c35c4687ed7e479">More...</a><br /></td></tr>
<tr class="separator:a9bd300616e9eef6a7c35c4687ed7e479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b7f679779d7f9c2d138b2380a4d0b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a36b7f679779d7f9c2d138b2380a4d0b0">n_choose_k</a> (int n, int k)</td></tr>
<tr class="memdesc:a36b7f679779d7f9c2d138b2380a4d0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the n choose k (binomial coefficient) function, from the MiXiM Framework Author Karl Wessel.  <a href="namespaceinet_1_1math.html#a36b7f679779d7f9c2d138b2380a4d0b0">More...</a><br /></td></tr>
<tr class="separator:a36b7f679779d7f9c2d138b2380a4d0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05f5f363b17f9e2cc464f2d812a6295"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab05f5f363b17f9e2cc464f2d812a6295"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ab05f5f363b17f9e2cc464f2d812a6295">minnan</a> (const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;a, const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;<a class="el" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</td></tr>
<tr class="memdesc:ab05f5f363b17f9e2cc464f2d812a6295"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function properly and symmetrically handles NaNs in contrast with std::min and std::fmin.  <a href="namespaceinet_1_1math.html#ab05f5f363b17f9e2cc464f2d812a6295">More...</a><br /></td></tr>
<tr class="separator:ab05f5f363b17f9e2cc464f2d812a6295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcb04b0e7b6f04876f0cadbdb37d7e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadcb04b0e7b6f04876f0cadbdb37d7e9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#aadcb04b0e7b6f04876f0cadbdb37d7e9">maxnan</a> (const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;a, const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;<a class="el" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</td></tr>
<tr class="memdesc:aadcb04b0e7b6f04876f0cadbdb37d7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function properly and symmetrically handles NaNs in contrast with std::max and std::fmax.  <a href="namespaceinet_1_1math.html#aadcb04b0e7b6f04876f0cadbdb37d7e9">More...</a><br /></td></tr>
<tr class="separator:aadcb04b0e7b6f04876f0cadbdb37d7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530d366613f640f91677b248439a9bf0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:a530d366613f640f91677b248439a9bf0"><td class="memTemplItemLeft" align="right" valign="top">Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html">DomainLimitedFunction</a>&lt; R, D &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a530d366613f640f91677b248439a9bf0">makeFirstQuadrantLimitedFunction</a> (const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;f)</td></tr>
<tr class="separator:a530d366613f640f91677b248439a9bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db3100b210e638bec7cff460c6a7aa0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D , int DIMS, typename RI , typename DI &gt; </td></tr>
<tr class="memitem:a6db3100b210e638bec7cff460c6a7aa0"><td class="memTemplItemLeft" align="right" valign="top">Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; RI, <a class="el" href="_ieee80211_vht_mode_8h.html#acabe1ee3d11be6214c678bf4dabda3c9">DI</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a6db3100b210e638bec7cff460c6a7aa0">integrate</a> (const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;f)</td></tr>
<tr class="separator:a6db3100b210e638bec7cff460c6a7aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6178a1b92c07990a26b0bd8c7780103a"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a6178a1b92c07990a26b0bd8c7780103a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a6178a1b92c07990a26b0bd8c7780103a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classinet_1_1math_1_1_domain.html">Domain</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt; &amp;d)</td></tr>
<tr class="separator:a6178a1b92c07990a26b0bd8c7780103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d585d7d5ec226cbe7442fd1a6cf8d74"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... T&gt; </td></tr>
<tr class="memitem:a6d585d7d5ec226cbe7442fd1a6cf8d74"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a6d585d7d5ec226cbe7442fd1a6cf8d74">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, <a class="el" href="classinet_1_1math_1_1_domain.html">Domain</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt;&gt; &amp;f)</td></tr>
<tr class="separator:a6d585d7d5ec226cbe7442fd1a6cf8d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fab1d0dea362fa129da3c60243729f6"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a7fab1d0dea362fa129da3c60243729f6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classinet_1_1math_1_1_i_interpolator.html">IInterpolator</a>&lt; X, Y &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a7fab1d0dea362fa129da3c60243729f6">createInterpolator</a> (const char *text)</td></tr>
<tr class="separator:a7fab1d0dea362fa129da3c60243729f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4eca85366c2045bf125108484c18a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#af4eca85366c2045bf125108484c18a19">iterateCorners</a> (const <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt;&gt; &amp;i, const std::function&lt; void(const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt;&gt; &amp;)&gt; f)</td></tr>
<tr class="separator:af4eca85366c2045bf125108484c18a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2a8bfeb663363abeb93c1b821d01f8"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename... TS&gt; </td></tr>
<tr class="memitem:a3a2a8bfeb663363abeb93c1b821d01f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a3a2a8bfeb663363abeb93c1b821d01f8">iterateCorners</a> (const <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt; T0, TS ... &gt; &amp;i, const std::function&lt; void(const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; T0, TS ... &gt; &amp;)&gt; f)</td></tr>
<tr class="separator:a3a2a8bfeb663363abeb93c1b821d01f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be5ed5327ae7ed5e09bac82e6c45bee"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a7be5ed5327ae7ed5e09bac82e6c45bee"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a7be5ed5327ae7ed5e09bac82e6c45bee">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt; &amp;i)</td></tr>
<tr class="separator:a7be5ed5327ae7ed5e09bac82e6c45bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ef96a2a4dbe9345f0c3aed7cbd10e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73ef96a2a4dbe9345f0c3aed7cbd10e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a73ef96a2a4dbe9345f0c3aed7cbd10e8">printUnit</a> (std::ostream &amp;os, <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> v)</td></tr>
<tr class="separator:a73ef96a2a4dbe9345f0c3aed7cbd10e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92c6dce154b3cc253fc0942e6b8d291"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae92c6dce154b3cc253fc0942e6b8d291"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ae92c6dce154b3cc253fc0942e6b8d291">printUnit</a> (std::ostream &amp;os, double v)</td></tr>
<tr class="separator:ae92c6dce154b3cc253fc0942e6b8d291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8293637d64b5f91846a1ec230473bb76"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8293637d64b5f91846a1ec230473bb76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a8293637d64b5f91846a1ec230473bb76">printUnit</a> (std::ostream &amp;os, simtime_t v)</td></tr>
<tr class="separator:a8293637d64b5f91846a1ec230473bb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d1a58b75e619d519a0e8722e87379d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae9d1a58b75e619d519a0e8722e87379d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ae9d1a58b75e619d519a0e8722e87379d">printUnit</a> (std::ostream &amp;os, <a class="el" href="classinet_1_1_quaternion.html">Quaternion</a> v)</td></tr>
<tr class="separator:ae9d1a58b75e619d519a0e8722e87379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bc5a49b216044a0e3eca99c9f16412"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a36bc5a49b216044a0e3eca99c9f16412"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a36bc5a49b216044a0e3eca99c9f16412">toDouble</a> (const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> v)</td></tr>
<tr class="separator:a36bc5a49b216044a0e3eca99c9f16412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af452e206195c533f4e81f319c8d0ce"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1af452e206195c533f4e81f319c8d0ce"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a1af452e206195c533f4e81f319c8d0ce">toDouble</a> (const <a class="el" href="namespaceinet_1_1units_1_1values.html#af0c9343e984dbcf72296f65579414ec9">simsec</a> v)</td></tr>
<tr class="separator:a1af452e206195c533f4e81f319c8d0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a52eda28998c86e22dd91f8d86319d0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1a52eda28998c86e22dd91f8d86319d0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a1a52eda28998c86e22dd91f8d86319d0">toDouble</a> (const double v)</td></tr>
<tr class="separator:a1a52eda28998c86e22dd91f8d86319d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf6fc10a9ad4e2de048198125d844d8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afaf6fc10a9ad4e2de048198125d844d8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#afaf6fc10a9ad4e2de048198125d844d8">toDouble</a> (const simtime_t v)</td></tr>
<tr class="separator:afaf6fc10a9ad4e2de048198125d844d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c649683d9e30fe0af2119c722e42d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67c649683d9e30fe0af2119c722e42d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a67c649683d9e30fe0af2119c722e42d2">getLowerBound</a> ()</td></tr>
<tr class="separator:a67c649683d9e30fe0af2119c722e42d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1f45d8b3c64d7bb2ed8663ccf48dbb"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3b1f45d8b3c64d7bb2ed8663ccf48dbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceinet_1_1units_1_1values.html#af0c9343e984dbcf72296f65579414ec9">simsec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a3b1f45d8b3c64d7bb2ed8663ccf48dbb">getLowerBound</a> ()</td></tr>
<tr class="separator:a3b1f45d8b3c64d7bb2ed8663ccf48dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aef2491ae66a1ce49f66eb4f9488d62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8aef2491ae66a1ce49f66eb4f9488d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a8aef2491ae66a1ce49f66eb4f9488d62">getUpperBound</a> ()</td></tr>
<tr class="separator:a8aef2491ae66a1ce49f66eb4f9488d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa77c632f9195caaf2250ad2dec832a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4fa77c632f9195caaf2250ad2dec832a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceinet_1_1units_1_1values.html#af0c9343e984dbcf72296f65579414ec9">simsec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a4fa77c632f9195caaf2250ad2dec832a">getUpperBound</a> ()</td></tr>
<tr class="separator:a4fa77c632f9195caaf2250ad2dec832a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e762654268b6ecddcb7dd91244afc7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... TS&gt; </td></tr>
<tr class="memitem:a41e762654268b6ecddcb7dd91244afc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a41e762654268b6ecddcb7dd91244afc7">head</a> (const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>, TS ... &gt; &amp;p)</td></tr>
<tr class="memdesc:a41e762654268b6ecddcb7dd91244afc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first coordinate of p.  <a href="namespaceinet_1_1math.html#a41e762654268b6ecddcb7dd91244afc7">More...</a><br /></td></tr>
<tr class="separator:a41e762654268b6ecddcb7dd91244afc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ee65a59d40315106967452251395ed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... TS&gt; </td></tr>
<tr class="memitem:a03ee65a59d40315106967452251395ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; TS ... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a03ee65a59d40315106967452251395ed">tail</a> (const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>, TS ... &gt; &amp;p)</td></tr>
<tr class="memdesc:a03ee65a59d40315106967452251395ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all but the first coordinate of p.  <a href="namespaceinet_1_1math.html#a03ee65a59d40315106967452251395ed">More...</a><br /></td></tr>
<tr class="separator:a03ee65a59d40315106967452251395ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a02e4290257e2c48006cc272bbaa240"><td class="memTemplParams" colspan="2">template&lt;typename... TS1, typename... TS2&gt; </td></tr>
<tr class="memitem:a9a02e4290257e2c48006cc272bbaa240"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; TS1 ..., TS2 ... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a9a02e4290257e2c48006cc272bbaa240">concat</a> (const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; TS1 ... &gt; &amp;p1, const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; TS2 ... &gt; &amp;p2)</td></tr>
<tr class="memdesc:a9a02e4290257e2c48006cc272bbaa240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a point by concatenating the coordinates of p1 and p2.  <a href="namespaceinet_1_1math.html#a9a02e4290257e2c48006cc272bbaa240">More...</a><br /></td></tr>
<tr class="separator:a9a02e4290257e2c48006cc272bbaa240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366cb6670e46fc2d52227fdc91b03512"><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr class="memitem:a366cb6670e46fc2d52227fdc91b03512"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a366cb6670e46fc2d52227fdc91b03512">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; T0 &gt; &amp;p)</td></tr>
<tr class="separator:a366cb6670e46fc2d52227fdc91b03512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4758923587cbbeee7bf1b6b724674625"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a4758923587cbbeee7bf1b6b724674625"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a4758923587cbbeee7bf1b6b724674625">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt; &amp;p)</td></tr>
<tr class="separator:a4758923587cbbeee7bf1b6b724674625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac568375a8be419ce5041063f109b6f57"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:ac568375a8be419ce5041063f109b6f57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ac568375a8be419ce5041063f109b6f57">simplifyAndCall</a> (const typename D::I &amp;i, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *f, const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt; callback)</td></tr>
<tr class="separator:ac568375a8be419ce5041063f109b6f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283aa71dc24ab4b91365590cae226c09"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:a283aa71dc24ab4b91365590cae226c09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a283aa71dc24ab4b91365590cae226c09">simplifyAndCall</a> (const typename D::I &amp;i, const <a class="el" href="classinet_1_1math_1_1_unilinear_function.html">UnilinearFunction</a>&lt; R, D &gt; *f, const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt; callback)</td></tr>
<tr class="separator:a283aa71dc24ab4b91365590cae226c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19aa6753450bccc6525bdf40f460002"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:ab19aa6753450bccc6525bdf40f460002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#ab19aa6753450bccc6525bdf40f460002">simplifyAndCall</a> (const typename D::I &amp;i, const <a class="el" href="classinet_1_1math_1_1_bilinear_function.html">BilinearFunction</a>&lt; R, D &gt; *f, const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt; callback)</td></tr>
<tr class="separator:ab19aa6753450bccc6525bdf40f460002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2a78dea1598d22deecc88d3b61379caf"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D , int DIMS, typename RI , typename DI &gt; </td></tr>
<tr class="memitem:a2a78dea1598d22deecc88d3b61379caf"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a2a78dea1598d22deecc88d3b61379caf">IntegratedFunction</a></td></tr>
<tr class="separator:a2a78dea1598d22deecc88d3b61379caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357bbe2e9fd46f0a175b3bc63965e3ca"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:a357bbe2e9fd46f0a175b3bc63965e3ca"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a357bbe2e9fd46f0a175b3bc63965e3ca">ConstantFunction</a></td></tr>
<tr class="separator:a357bbe2e9fd46f0a175b3bc63965e3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c89d882ac6a899a2891cc60d827693"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:a39c89d882ac6a899a2891cc60d827693"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a39c89d882ac6a899a2891cc60d827693">AddedFunction</a></td></tr>
<tr class="separator:a39c89d882ac6a899a2891cc60d827693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9664f1b7ea21c27a4fc2ad259463a48"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:af9664f1b7ea21c27a4fc2ad259463a48"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#af9664f1b7ea21c27a4fc2ad259463a48">SubtractedFunction</a></td></tr>
<tr class="separator:af9664f1b7ea21c27a4fc2ad259463a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021a692ea7e1697fff11286c76ae4721"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:a021a692ea7e1697fff11286c76ae4721"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a021a692ea7e1697fff11286c76ae4721">MultipliedFunction</a></td></tr>
<tr class="separator:a021a692ea7e1697fff11286c76ae4721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c84a5ef3da8175f7fccec037ef4bfe"><td class="memTemplParams" colspan="2">template&lt;typename R , typename D &gt; </td></tr>
<tr class="memitem:a06c84a5ef3da8175f7fccec037ef4bfe"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinet_1_1math.html#a06c84a5ef3da8175f7fccec037ef4bfe">DividedFunction</a></td></tr>
<tr class="separator:a06c84a5ef3da8175f7fccec037ef4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support functions for mathematical operations. </p>
<p>This namespace contains all kind of mathematical support functions </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab64f9f74bdc3d9579b6efcf3e90ea795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64f9f74bdc3d9579b6efcf3e90ea795">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::clamp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;{ <span class="keywordflow">return</span> v &lt; l ? l : v &gt; u ? u : v; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_coord.html#a249e827129a4c3d4ec9f4dd0b434aff8">inet::Coord::clamp()</a>.</p>

</div>
</div>
<a id="a838c5a6b516bfc8bfa4f582f26111f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838c5a6b516bfc8bfa4f582f26111f71">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool inet::math::close </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>two</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether two doubles are close enough to be declared equal. </p>
<p>Returns true if parameters are at most epsilon apart, false otherwise </p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;{ <span class="keywordflow">return</span> fabs(one - two) &lt; <a class="code" href="_i_n_e_t_math_8h.html#a002b2f4894492820fe708b1b7e7c5e70">EPSILON</a>; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_posture_transition.html#ab284ea669cd57317482a38c70c8b420a">inet::PostureTransition::isMarkovian()</a>, <a class="el" href="classinet_1_1_rotation_matrix.html#a1762bc953179b9928c3301133e22ebb6">inet::RotationMatrix::RotationMatrix()</a>, <a class="el" href="namespaceinet_1_1math.html#a285a7068f428a9c3a06527de64a7a403">stepfunction()</a>, and <a class="el" href="classinet_1_1_network_namespace_context.html#af8ec3854fbc9c8a60d15de94bd8ee8bf">inet::NetworkNamespaceContext::~NetworkNamespaceContext()</a>.</p>

</div>
</div>
<a id="a9a02e4290257e2c48006cc272bbaa240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a02e4290257e2c48006cc272bbaa240">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TS1, typename... TS2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt;TS1 ..., TS2 ...&gt; inet::math::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; TS1 ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; TS2 ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a point by concatenating the coordinates of p1 and p2. </p>
<div class="fragment"><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1math_1_1internal.html#a8f1c5ab47a17ea8cc0c8bc2c25026c4e">internal::concatImpl</a>(p1, std::index_sequence_for&lt;TS1 ...&gt;{}, p2, std::index_sequence_for&lt;TS2 ...&gt;{});</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_left_currying_function.html#a4519a1777c1a41dd25f34e89456a1cac">inet::math::LeftCurryingFunction&lt; R, C, DIMSC, D, DIMSD, E &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_right_currying_function.html#aa93c25a7e82079455a64c01a9f756d31">inet::math::RightCurryingFunction&lt; R, C, DIMSC, D, DIMSD, E &gt;::getValue()</a>, <a class="el" href="namespaceinet_1_1math.html#a3a2a8bfeb663363abeb93c1b821d01f8">iterateCorners()</a>, <a class="el" href="classinet_1_1math_1_1_left_currying_function.html#adfaf0f113c2dd53aab47be42c31bd6a0">inet::math::LeftCurryingFunction&lt; R, C, DIMSC, D, DIMSD, E &gt;::partition()</a>, and <a class="el" href="classinet_1_1math_1_1_right_currying_function.html#acf2d1a8065ce5f4074ce22b1688ecd6d">inet::math::RightCurryingFunction&lt; R, C, DIMSC, D, DIMSD, E &gt;::partition()</a>.</p>

</div>
</div>
<a id="a7fab1d0dea362fa129da3c60243729f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fab1d0dea362fa129da3c60243729f6">&#9670;&nbsp;</a></span>createInterpolator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classinet_1_1math_1_1_i_interpolator.html">IInterpolator</a>&lt;X, Y&gt;* inet::math::createInterpolator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                                                                {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;either&quot;</span>, text))</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordflow">return</span> &amp;EitherInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;left&quot;</span>, text))</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordflow">return</span> &amp;LeftInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;right&quot;</span>, text))</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="keywordflow">return</span> &amp;RightInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;average&quot;</span>, text))</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">return</span> &amp;AverageInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;closer&quot;</span>, text))</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keywordflow">return</span> &amp;CloserInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;minimum&quot;</span>, text))</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keywordflow">return</span> &amp;MinimumInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;maximum&quot;</span>, text))</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="keywordflow">return</span> &amp;MaximumInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;linear&quot;</span>, text))</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <span class="keywordflow">return</span> &amp;LinearInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(<span class="stringliteral">&quot;lineardb&quot;</span>, text))</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keywordflow">return</span> &amp;LineardbInterpolator&lt;X, Y&gt;::singleton;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;Unknown interpolator: &#39;%s&#39;&quot;</span>, text);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a46417f0a1e03abab8b2d23eba8ee63d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46417f0a1e03abab8b2d23eba8ee63d6">&#9670;&nbsp;</a></span>dB2fraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::dB2fraction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a dB value to fraction. </p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;{ <span class="keywordflow">return</span> pow(10.0, dB / 10.0); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_axially_symmetric_antenna_1_1_antenna_gain.html#a8f4a8f16c98225ba0bbc2f984eba1c71">inet::physicallayer::AxiallySymmetricAntenna::AntennaGain::AntennaGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_parabolic_antenna_1_1_antenna_gain.html#ab4a3b8d77d48598c38bf93720eac7f8e">inet::physicallayer::ParabolicAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_medium_limit_cache.html#ade1644c577cab44894796e3923a58cfb">inet::physicallayer::MediumLimitCache::computeMaxAntennaGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_uwb_ir_stochastic_path_loss.html#a6bf32ced53dd51f85bf1fd88b8fa474d">inet::physicallayer::UwbIrStochasticPathLoss::getGhassemzadehPathLoss()</a>, <a class="el" href="classinet_1_1math_1_1_lineardb_interpolator.html#a6c1229f969bcbed0a4fec3a8f6ccb6ff">inet::math::LineardbInterpolator&lt; X, Y &gt;::getMean()</a>, <a class="el" href="classinet_1_1math_1_1_lineardb_interpolator.html#a189f547b81a0d1aa0585372d512c186a">inet::math::LineardbInterpolator&lt; X, Y &gt;::getValue()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_constant_gain_antenna.html#ac89bbcdfe4405b9238d1565e5bd98397">inet::physicallayer::ConstantGainAntenna::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_cosine_antenna.html#adb6e0bb9eb039353f469926220ff2f59">inet::physicallayer::CosineAntenna::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_breakpoint_path_loss.html#a93dea47ab74a889f4e305e6afb4d41cf">inet::physicallayer::BreakpointPathLoss::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_snir_receiver_base.html#a2b0478c28925aaced4e37cd902516470">inet::physicallayer::SnirReceiverBase::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_parabolic_antenna.html#a1e80623d6602fa51216b3610b443a6d2">inet::physicallayer::ParabolicAntenna::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_axially_symmetric_antenna.html#ad51066ec6fa5f5eef924b7e8b0a52676">inet::physicallayer::AxiallySymmetricAntenna::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_error_model_base.html#ae68bf1677332f824956e3de10e31a6e6">inet::physicallayer::ErrorModelBase::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_dimensional_transmitter_base.html#af5495e695153cc026f75f906839e783c">inet::physicallayer::DimensionalTransmitterBase::parseGains()</a>, and <a class="el" href="classinet_1_1physicallayer_1_1_interpolating_antenna_1_1_antenna_gain.html#a08c702b089ed425e3fd1184adf24bf2d">inet::physicallayer::InterpolatingAntenna::AntennaGain::parseMap()</a>.</p>

</div>
</div>
<a id="ab1bd082504cd879d1aaeb7f55b9ced17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bd082504cd879d1aaeb7f55b9ced17">&#9670;&nbsp;</a></span>dBmW2mW()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::dBmW2mW </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dBm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a dBmW value to mW. </p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;{ <span class="keywordflow">return</span> pow(10.0, dBm / 10.0); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_medium_limit_cache.html#a42e87f6bf76426d7ea4a56f8984c4be4">inet::physicallayer::MediumLimitCache::computeMinInterferencePower()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_medium_limit_cache.html#a28e00e15eed031603274d2f1946b19fd">inet::physicallayer::MediumLimitCache::computeMinReceptionPower()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_isotropic_scalar_background_noise.html#af9c50b7f76c2c7d70d2a131bd99fefdd">inet::physicallayer::IsotropicScalarBackgroundNoise::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_dimensional_background_noise.html#a6bef57025ade4b3bf896a510bb451074">inet::physicallayer::DimensionalBackgroundNoise::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_isotropic_dimensional_background_noise.html#a43cecd016f77a5b45db6fcd1d44cd266">inet::physicallayer::IsotropicDimensionalBackgroundNoise::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee802154_narrowband_dimensional_receiver.html#ad967ce708d7b78be481a4dcdb765de8d">inet::physicallayer::Ieee802154NarrowbandDimensionalReceiver::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee802154_narrowband_scalar_receiver.html#ab9f81a4ed143c8cdcda1c463fe6c6a94">inet::physicallayer::Ieee802154NarrowbandScalarReceiver::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_flat_receiver_base.html#ad5ab2223b688abaa333bff0ab43658f0">inet::physicallayer::FlatReceiverBase::initialize()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_apsk_layered_receiver.html#a8939f739d042db9a7ec8e70e3230c170">inet::physicallayer::ApskLayeredReceiver::initialize()</a>, and <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_layered_ofdm_receiver.html#a3dd37d765da7a71835f33885b662f610">inet::physicallayer::Ieee80211LayeredOfdmReceiver::initialize()</a>.</p>

</div>
</div>
<a id="a5653a8e0cc6d926f2790f713c9619a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5653a8e0cc6d926f2790f713c9619a31">&#9670;&nbsp;</a></span>dBmWpMHz2WpHz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::dBmWpMHz2WpHz </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dBmWpMHz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a dBmW/MHz value into W/Hz. </p>
<div class="fragment"><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;{ <span class="keywordflow">return</span> pow(10.0, dBmWpMHz / 10.0) / 1000000.0 / 1000.0; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_isotropic_dimensional_background_noise.html#a43cecd016f77a5b45db6fcd1d44cd266">inet::physicallayer::IsotropicDimensionalBackgroundNoise::initialize()</a>.</p>

</div>
</div>
<a id="ac5930cf83a8b56c5bf1dc5f0a634d5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5930cf83a8b56c5bf1dc5f0a634d5f1">&#9670;&nbsp;</a></span>deg2rad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::deg2rad </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a degree value to radian. </p>
<div class="fragment"><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1units.html#a3bbcccd55eaf6edd8ab07f78d17c2f44">deg</a> * <a class="code" href="_i_n_e_t_math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 180; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_cosine_antenna_1_1_antenna_gain.html#a2d05dfce810bae6a2c991ce06cf51e2b">inet::physicallayer::CosineAntenna::AntennaGain::computeGain()</a>, and <a class="el" href="classinet_1_1_stationary_mobility.html#a95178d2e9963efaff9a69c49ae3a72fb">inet::StationaryMobility::updateMobilityStateFromDisplayString()</a>.</p>

</div>
</div>
<a id="a8ec61226382f9d47b30002d6dadc903e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec61226382f9d47b30002d6dadc903e">&#9670;&nbsp;</a></span>div()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::div </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of a whole-numbered division. </p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;{</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordtype">double</span> i;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    modf(dividend / divisor, &amp;i);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">return</span> i;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_int128.html#ac12f9226cdb892aaabf9fb2d7b6fb335">inet::Int128::operator%=()</a>, and <a class="el" href="classinet_1_1_int128.html#ad76f6d5c5d5207c1f891209014f62c3e">inet::Int128::operator/=()</a>.</p>

</div>
</div>
<a id="a61500313b7dc4a2130ddc44a55a8058c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61500313b7dc4a2130ddc44a55a8058c">&#9670;&nbsp;</a></span>floorToZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::floorToZero </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards the fractional part of the parameter, e.g. </p>
<p>-3.8 becomes -3 </p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{ <span class="keywordflow">return</span> (d &gt;= 0.0) ? floor(d) : ceil(d); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a979fd42fd8afd4174e8608891f670c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979fd42fd8afd4174e8608891f670c62">&#9670;&nbsp;</a></span>fraction2dB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::fraction2dB </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fraction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a fraction value to dB. </p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;{ <span class="keywordflow">return</span> 10 * log10(fraction); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1visualizer_1_1_tracing_obstacle_loss_canvas_visualizer.html#ac8f95449ec5525f7a66739f5b633b871">inet::visualizer::TracingObstacleLossCanvasVisualizer::createObstacleLossVisualization()</a>, <a class="el" href="classinet_1_1math_1_1_lineardb_interpolator.html#a6c1229f969bcbed0a4fec3a8f6ccb6ff">inet::math::LineardbInterpolator&lt; X, Y &gt;::getMean()</a>, and <a class="el" href="classinet_1_1math_1_1_lineardb_interpolator.html#a189f547b81a0d1aa0585372d512c186a">inet::math::LineardbInterpolator&lt; X, Y &gt;::getValue()</a>.</p>

</div>
</div>
<a id="a67c649683d9e30fe0af2119c722e42d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c649683d9e30fe0af2119c722e42d2">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> inet::math::getLowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1units.html#a42b16566603bd538f97d32035852b7b5">T</a>(-<a class="code" href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a>); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b1f45d8b3c64d7bb2ed8663ccf48dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1f45d8b3c64d7bb2ed8663ccf48dbb">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t inet::math::getLowerBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#af0c9343e984dbcf72296f65579414ec9">simsec</a>(-SimTime::getMaxTime() / 2); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8aef2491ae66a1ce49f66eb4f9488d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aef2491ae66a1ce49f66eb4f9488d62">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> inet::math::getUpperBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1units.html#a42b16566603bd538f97d32035852b7b5">T</a>(<a class="code" href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a>); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4fa77c632f9195caaf2250ad2dec832a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa77c632f9195caaf2250ad2dec832a">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t inet::math::getUpperBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#af0c9343e984dbcf72296f65579414ec9">simsec</a>(SimTime::getMaxTime() / 2); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a41e762654268b6ecddcb7dd91244afc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e762654268b6ecddcb7dd91244afc7">&#9670;&nbsp;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> inet::math::head </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>, TS ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first coordinate of p. </p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                                  {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">return</span> std::get&lt;0&gt;(p);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_ipv6_neighbour_cache_1_1_default_router_list.html#a9bb865159f42b54ae50b8d362852ef17">inet::Ipv6NeighbourCache::DefaultRouterList::begin()</a>, <a class="el" href="classinet_1_1_ipv6_neighbour_cache_1_1_default_router_list.html#a8604194b2063fca8ff04dc5abfb6db46">inet::Ipv6NeighbourCache::DefaultRouterList::clear()</a>, <a class="el" href="classinet_1_1_ipv6_neighbour_cache_1_1_default_router_list.html#a02394863b8fbf9156e716cbcc1b29fe8">inet::Ipv6NeighbourCache::DefaultRouterList::getHead()</a>, <a class="el" href="namespaceinet_1_1math.html#a3a2a8bfeb663363abeb93c1b821d01f8">iterateCorners()</a>, <a class="el" href="classinet_1_1ospfv2_1_1_router.html#a3cb23dfc119694561a4f6ef5c53314b4">inet::ospfv2::Router::printAsExternalLsa()</a>, <a class="el" href="classinet_1_1ospfv2_1_1_ospfv2_area.html#a756aef89b5d42d0434c3d0db2d763e3c">inet::ospfv2::Ospfv2Area::printLSDB()</a>, <a class="el" href="classinet_1_1ospfv2_1_1_ospfv2_area.html#a3c066e59bc5df36ab7123e6685de6d98">inet::ospfv2::Ospfv2Area::printSummaryLsa()</a>, <a class="el" href="classinet_1_1_ipv6_neighbour_cache_1_1_default_router_list.html#a2651b0bf4cd978f3caaebcac865bb53d">inet::Ipv6NeighbourCache::DefaultRouterList::remove()</a>, and <a class="el" href="classinet_1_1_ipv6_neighbour_cache_1_1_default_router_list.html#a451752a1c5ed5307d0c454e9348e505a">inet::Ipv6NeighbourCache::DefaultRouterList::setHead()</a>.</p>

</div>
</div>
<a id="a6db3100b210e638bec7cff460c6a7aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db3100b210e638bec7cff460c6a7aa0">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D , int DIMS, typename RI , typename DI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ptr&lt;const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt;RI, <a class="el" href="_ieee80211_vht_mode_8h.html#acabe1ee3d11be6214c678bf4dabda3c9">DI</a>&gt; &gt; inet::math::integrate </td>
          <td>(</td>
          <td class="paramtype">const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                                                                            {</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    <span class="keywordflow">return</span> makeShared&lt;IntegratedFunction&lt;R, D, DIMS, RI, DI&gt;&gt;(f);</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3a2a8bfeb663363abeb93c1b821d01f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2a8bfeb663363abeb93c1b821d01f8">&#9670;&nbsp;</a></span>iterateCorners() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename... TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::iterateCorners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt; T0, TS ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; T0, TS ... &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                                                                                                               {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    Interval&lt;TS ...&gt; i1(<a class="code" href="namespaceinet_1_1math.html#a03ee65a59d40315106967452251395ed">tail</a>(i.getLower()), <a class="code" href="namespaceinet_1_1math.html#a03ee65a59d40315106967452251395ed">tail</a>(i.getUpper()), i.getLowerClosed() &gt;&gt; 1, i.getUpperClosed() &gt;&gt; 1, i.getFixed() &gt;&gt; 1);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <a class="code" href="namespaceinet_1_1math.html#a3a2a8bfeb663363abeb93c1b821d01f8">iterateCorners</a>(i1, std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> Point&lt;TS ...&gt;&amp;)&gt;([&amp;] (<span class="keyword">const</span> Point&lt;TS ...&gt;&amp; q) {</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        f(<a class="code" href="namespaceinet_1_1math.html#a9a02e4290257e2c48006cc272bbaa240">concat</a>(Point&lt;T0&gt;(<a class="code" href="namespaceinet_1_1math.html#a41e762654268b6ecddcb7dd91244afc7">head</a>(i.getLower())), q));</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        f(<a class="code" href="namespaceinet_1_1math.html#a9a02e4290257e2c48006cc272bbaa240">concat</a>(Point&lt;T0&gt;(<a class="code" href="namespaceinet_1_1math.html#a41e762654268b6ecddcb7dd91244afc7">head</a>(i.getUpper())), q));</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    }));</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4eca85366c2045bf125108484c18a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4eca85366c2045bf125108484c18a19">&#9670;&nbsp;</a></span>iterateCorners() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::iterateCorners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt;&gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                                                                                           {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    f(Point&lt;&gt;());</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_function_checker.html#af4722fd0cb5dc34c949741f320843d44">inet::math::FunctionChecker&lt; R, D &gt;::check()</a>, <a class="el" href="namespaceinet_1_1math.html#a3a2a8bfeb663363abeb93c1b821d01f8">iterateCorners()</a>, and <a class="el" href="classinet_1_1math_1_1_function_base.html#a186d11b46c8fb589798f9319b14fad48">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::printPartition()</a>.</p>

</div>
</div>
<a id="a530d366613f640f91677b248439a9bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530d366613f640f91677b248439a9bf0">&#9670;&nbsp;</a></span>makeFirstQuadrantLimitedFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ptr&lt;const <a class="el" href="classinet_1_1math_1_1_domain_limited_function.html">DomainLimitedFunction</a>&lt;R, D&gt; &gt; inet::math::makeFirstQuadrantLimitedFunction </td>
          <td>(</td>
          <td class="paramtype">const Ptr&lt; const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                                                                                             {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keyword">auto</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#a44d9b2566a438eba4f0f692170691276">m</a> = (1 &lt;&lt; std::tuple_size&lt;typename D::P::type&gt;::value) - 1;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keyword">typename</span> D::I i(D::P::getZero(), D::P::getUpperBounds(), <a class="code" href="namespaceinet_1_1units_1_1values.html#a44d9b2566a438eba4f0f692170691276">m</a>, 0, 0);</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keywordflow">return</span> makeShared&lt;DomainLimitedFunction&lt;R, D&gt;&gt;(f, i);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_isotropic_dimensional_background_noise.html#af55ccc358c6e3e727a823bf577ea92a4">inet::physicallayer::IsotropicDimensionalBackgroundNoise::computeNoise()</a>, and <a class="el" href="classinet_1_1physicallayer_1_1_dimensional_transmitter_base.html#afaf6b1fab74f117e33829297f91bb0cd">inet::physicallayer::DimensionalTransmitterBase::createPowerFunction()</a>.</p>

</div>
</div>
<a id="aadcb04b0e7b6f04876f0cadbdb37d7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcb04b0e7b6f04876f0cadbdb37d7e9">&#9670;&nbsp;</a></span>maxnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> inet::math::maxnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function properly and symmetrically handles NaNs in contrast with std::max and std::fmax. </p>
<p>For example, the maximum of NaN and 1 must be NaN independently of the argument order. See 'Not a number' section at <a href="https://2pi.dk/2016/05/ieee-min-max">https://2pi.dk/2016/05/ieee-min-max</a> </p>
<div class="fragment"><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                                              {</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;static_assert(!std::is_integral&lt;T&gt;::value, <span class="stringliteral">&quot;maxnan() is only meant for doubles and double based units, use std::max() for integers&quot;</span>);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="keywordflow">if</span> (a &gt; <a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a> &gt; a)</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a == <a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1units.html#a42b16566603bd538f97d32035852b7b5">T</a>(<a class="code" href="_i_n_e_t_math_8h.html#a953f667fb27fb68dd74a487d002b19b5">NaN</a>);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_parabolic_antenna_1_1_antenna_gain.html#ab4a3b8d77d48598c38bf93720eac7f8e">inet::physicallayer::ParabolicAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_cosine_antenna_1_1_antenna_gain.html#a2d05dfce810bae6a2c991ce06cf51e2b">inet::physicallayer::CosineAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_dipole_antenna_1_1_antenna_gain.html#a7ca0d1993fecdc1123213c642c2256f4">inet::physicallayer::DipoleAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_axially_symmetric_antenna_1_1_antenna_gain.html#a2d866e150589578999d6637c7f6f9f20">inet::physicallayer::AxiallySymmetricAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1_cuboid.html#acbd766e19375b22cf7608ea901cef5a6">inet::Cuboid::computeIntersection()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_convolutional_code.html#a3da32afac0915ef3681141ede60f8d49">inet::physicallayer::ConvolutionalCode::computeNetBitErrorRate()</a>, <a class="el" href="classinet_1_1math_1_1_interpolator_base.html#a62f13c57163527a3ab60badbbcccfa83">inet::math::InterpolatorBase&lt; X, Y &gt;::getMax()</a>, <a class="el" href="classinet_1_1math_1_1_function_base.html#aa0d2637a37dd5b70030eb9bbb95d6edf">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::getMax()</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a61e1180dd46ffc1ecdcb65a22ab3ef7b">inet::math::UnilinearFunction&lt; R, D &gt;::getMax()</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#a00d12876b561bbfcfe951e80fdd080e3">inet::math::BilinearFunction&lt; R, D &gt;::getMax()</a>, <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#abfebdfd74561e069282b064335473c55">inet::math::UnireciprocalFunction&lt; R, D &gt;::getMax()</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a67e1c67741061c48f1863f6a1a50ae8b">inet::math::UnilinearFunction&lt; R, D &gt;::getRange()</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#a5341d01e361136008b4ff80fda0c7758">inet::math::BilinearFunction&lt; R, D &gt;::getRange()</a>, <a class="el" href="classinet_1_1math_1_1_maximum_interpolator.html#a794ff8932653bb5daeeda8b9aff6f1de">inet::math::MaximumInterpolator&lt; X, Y &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_interval.html#ad963d9e194dd074c675cbc03e7509af2">inet::math::Interval&lt; R &gt;::intersectImpl()</a>, and <a class="el" href="classinet_1_1_quaternion.html#a77ab39052c436778709eb9c6ae0c8c84">inet::Quaternion::toEulerAngles()</a>.</p>

</div>
</div>
<a id="ab05f5f363b17f9e2cc464f2d812a6295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05f5f363b17f9e2cc464f2d812a6295">&#9670;&nbsp;</a></span>minnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> inet::math::minnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function properly and symmetrically handles NaNs in contrast with std::min and std::fmin. </p>
<p>For example, the minimum of NaN and 1 must be NaN independently of the argument order. See 'Not a number' section at <a href="https://2pi.dk/2016/05/ieee-min-max">https://2pi.dk/2016/05/ieee-min-max</a> </p>
<div class="fragment"><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                                              {</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;static_assert(!std::is_integral&lt;T&gt;::value, <span class="stringliteral">&quot;minnan() is only meant for doubles and double based units, use std::min() for integers&quot;</span>);</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="keywordflow">if</span> (a &lt; <a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a> &lt; a)</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a == <a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a>)</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1units.html#a42b16566603bd538f97d32035852b7b5">T</a>(<a class="code" href="_i_n_e_t_math_8h.html#a953f667fb27fb68dd74a487d002b19b5">NaN</a>);</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_parabolic_antenna_1_1_antenna_gain.html#ab4a3b8d77d48598c38bf93720eac7f8e">inet::physicallayer::ParabolicAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_cosine_antenna_1_1_antenna_gain.html#a2d05dfce810bae6a2c991ce06cf51e2b">inet::physicallayer::CosineAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_axially_symmetric_antenna_1_1_antenna_gain.html#a2d866e150589578999d6637c7f6f9f20">inet::physicallayer::AxiallySymmetricAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_dipole_antenna_1_1_antenna_gain.html#a7ca0d1993fecdc1123213c642c2256f4">inet::physicallayer::DipoleAntenna::AntennaGain::computeGain()</a>, <a class="el" href="classinet_1_1_cuboid.html#acbd766e19375b22cf7608ea901cef5a6">inet::Cuboid::computeIntersection()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_convolutional_code.html#a3da32afac0915ef3681141ede60f8d49">inet::physicallayer::ConvolutionalCode::computeNetBitErrorRate()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_nist_error_model.html#a356b2d351d34a718fe86292e2845be84">inet::physicallayer::Ieee80211NistErrorModel::getFec1024QamBer()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_nist_error_model.html#ada0859feeebb1ce1d7f99211eac3d710">inet::physicallayer::Ieee80211NistErrorModel::getFec16QamBer()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_nist_error_model.html#a40f5033f2b49e27b427a304b5499c76c">inet::physicallayer::Ieee80211NistErrorModel::getFec256QamBer()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_nist_error_model.html#a0135d97287c8c6e985035f2cc05a8032">inet::physicallayer::Ieee80211NistErrorModel::getFec64QamBer()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_nist_error_model.html#a01e56cccc82c6f07b9255233058d7c05">inet::physicallayer::Ieee80211NistErrorModel::getFecBpskBer()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_yans_error_model.html#abe9f96fa11f79d4d70fde7e67a420570">inet::physicallayer::Ieee80211YansErrorModel::getFecBpskBer()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_yans_error_model.html#a8870e412eac9de1fe69c4cad385d7594">inet::physicallayer::Ieee80211YansErrorModel::getFecQamBer()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_ieee80211_nist_error_model.html#aa6d3ab5e4fe03f6ef6846cc8ba434565">inet::physicallayer::Ieee80211NistErrorModel::getFecQpskBer()</a>, <a class="el" href="classinet_1_1math_1_1_interpolator_base.html#a677e2b56a68bb64d672c98a63e176353">inet::math::InterpolatorBase&lt; X, Y &gt;::getMin()</a>, <a class="el" href="classinet_1_1math_1_1_function_base.html#ad5b19c1130b3e7e918318fd042c71790">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::getMin()</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a7390408ce9e6b60b71df47b03ae954cb">inet::math::UnilinearFunction&lt; R, D &gt;::getMin()</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#ab1e868f66b628fdacf226a42f9800094">inet::math::BilinearFunction&lt; R, D &gt;::getMin()</a>, <a class="el" href="classinet_1_1math_1_1_unireciprocal_function.html#a70403a41beddf7ac1a4902306cb054e9">inet::math::UnireciprocalFunction&lt; R, D &gt;::getMin()</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a67e1c67741061c48f1863f6a1a50ae8b">inet::math::UnilinearFunction&lt; R, D &gt;::getRange()</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#a5341d01e361136008b4ff80fda0c7758">inet::math::BilinearFunction&lt; R, D &gt;::getRange()</a>, <a class="el" href="classinet_1_1math_1_1_minimum_interpolator.html#a326df38b859be81d2286aabc7b09db4f">inet::math::MinimumInterpolator&lt; X, Y &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_approximated_function.html#a1225be4543be356c0f72bfcee3afe74d">inet::math::ApproximatedFunction&lt; R, D, DIMENSION, X &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_interval.html#ad963d9e194dd074c675cbc03e7509af2">inet::math::Interval&lt; R &gt;::intersectImpl()</a>, and <a class="el" href="classinet_1_1_quaternion.html#a77ab39052c436778709eb9c6ae0c8c84">inet::Quaternion::toEulerAngles()</a>.</p>

</div>
</div>
<a id="a48eb5699c67c54008123531fa3267c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48eb5699c67c54008123531fa3267c30">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::mod </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rest of a whole-numbered division. </p>
<div class="fragment"><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;{</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordtype">double</span> i;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">return</span> modf(dividend / divisor, &amp;i) * divisor;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="namespaceinet.html#ac76a93cfc8469df49ab00e413eba7a37">inet::_isNetworkNode()</a>, <a class="el" href="classinet_1_1_ted.html#abe1d7fa50634e87d97430becb6e8aee8">inet::Ted::calculateShortestPaths()</a>, <a class="el" href="classinet_1_1_ipv6_flat_network_configurator.html#abf83d7b71092ee7bde5381ae19fdea25">inet::Ipv6FlatNetworkConfigurator::configureAdvPrefixes()</a>, <a class="el" href="classinet_1_1_topology.html#a0d7b227585c394dd6b195c8e7f0f129f">inet::Topology::extractFromNetwork()</a>, <a class="el" href="classinet_1_1_ipv4_flat_network_configurator.html#a33bc6925436ad4964365f77597ab0287">inet::Ipv4FlatNetworkConfigurator::extractTopology()</a>, <a class="el" href="classinet_1_1_l3_address_resolver.html#aa15c0d8073fa0191336fa803453900ac">inet::L3AddressResolver::findHostWithAddress()</a>, <a class="el" href="classinet_1_1_l3_address_resolver.html#added41d88e0222febf76a0ed52935ef5">inet::L3AddressResolver::findInterfaceWithMacAddress()</a>, <a class="el" href="namespaceinet.html#a7a557eb8aeb2c1cce858bcfceed2c499">inet::findModuleFromPar()</a>, <a class="el" href="namespaceinet.html#a63866b6ffde6b746fac4a19d97e6f67f">inet::findModuleSomewhereUp()</a>, <a class="el" href="classinet_1_1_topology.html#a473823ca721e0c7d833aa7464e0e3fa9">inet::Topology::findNetworks()</a>, <a class="el" href="classinet_1_1_l3_address_resolver.html#a4cab26dfe0b9bba3931c74d1966a9de7">inet::L3AddressResolver::getIpv4RoutingTableOf()</a>, <a class="el" href="classinet_1_1_l3_address_resolver.html#ad7646fb80299cf8ccbfbcf3de14eb2b7">inet::L3AddressResolver::getIpv6RoutingTableOf()</a>, <a class="el" href="namespaceinet.html#a4bb6eb7da265e1ac332c62f92a9a1ff7">inet::getModuleFromPar()</a>, <a class="el" href="classinet_1_1_topology.html#ad83dbad494392c1a5e63e43577198bdb">inet::Topology::getNodeFor()</a>, <a class="el" href="classinet_1_1_scenario_manager.html#a9a218f8c473012c47841de87a6754626">inet::ScenarioManager::getRequiredModule()</a>, <a class="el" href="classinet_1_1_ted.html#a7d26d9fdad7cfed57a979c55af1fb606">inet::Ted::initializeTED()</a>, <a class="el" href="classinet_1_1_l3_address_resolver.html#afeaa6119cd9b7ab0cd30ca875dd502fa">inet::L3AddressResolver::interfaceTableOf()</a>, <a class="el" href="namespaceinet_1_1queueing.html#ae11be216ebff738084dff8db0f8c221c">inet::queueing::isApplication()</a>, <a class="el" href="namespaceinet.html#a8082b71088f1285087570e2d181b8ec4">inet::isNetworkNode()</a>, <a class="el" href="classinet_1_1_scenario_manager.html#a2a66ae37fb9f3db17133e6ce7af94af0">inet::ScenarioManager::processModuleSpecificCommand()</a>, <a class="el" href="classinet_1_1_scenario_manager.html#af760e70b1a4f3215d1521ad174084ca2">inet::ScenarioManager::processSetParamCommand()</a>, <a class="el" href="classinet_1_1_rsvp_te.html#af68b84b869a9133dad1ca54f8c0fdc93">inet::RsvpTe::readTrafficSessionFromXML()</a>, <a class="el" href="classinet_1_1_rsvp_te.html#af3c85f99f333310620a9d7de3c830cc3">inet::RsvpTe::sendPathNotify()</a>, and <a class="el" href="classinet_1_1_l3_address_resolver.html#a8e7d4f12a146e932b86e8c1b05e18bc4">inet::L3AddressResolver::tryResolve()</a>.</p>

</div>
</div>
<a id="a3769b32c794160d2565384dcdd1e47dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3769b32c794160d2565384dcdd1e47dc">&#9670;&nbsp;</a></span>modulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::modulo </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the remainder r on division of dividend a by divisor n, using floored division. </p>
<p>The remainder r has the same sign as the divisor n. </p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;{ <span class="keywordflow">return</span> a - n * floor(a / n); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_euler_angles.html#aebd6341764a82bd033a9000a194de5e9">inet::EulerAngles::normalize()</a>.</p>

</div>
</div>
<a id="a1885b885fdbadd7bd599451f5f2c07f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1885b885fdbadd7bd599451f5f2c07f4">&#9670;&nbsp;</a></span>mW2dBmW()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::mW2dBmW </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mW</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a mW value to dBmW. </p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{ <span class="keywordflow">return</span> 10.0 * log10(<a class="code" href="namespaceinet_1_1units_1_1units.html#a1b9208dd83b11d5f1769be7650d64c18">mW</a>); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1visualizer_1_1_ieee80211_visualizer_base.html#ac6c890027612e01183938f32d2cd55a6">inet::visualizer::Ieee80211VisualizerBase::getIcon()</a>.</p>

</div>
</div>
<a id="a36b7f679779d7f9c2d138b2380a4d0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b7f679779d7f9c2d138b2380a4d0b0">&#9670;&nbsp;</a></span>n_choose_k()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::n_choose_k </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the n choose k (binomial coefficient) function, from the MiXiM Framework Author Karl Wessel. </p>
<div class="fragment"><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                                       {</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">if</span> (n &lt; <a class="code" href="namespaceinet_1_1physicallayer.html#ab2efa56aa3bcc6b59af7ce2efdcfc9d8">k</a>)</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="keywordflow">return</span> 0.0;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160; </div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">int</span> iK = (k &lt;&lt; 1) &gt; n ? n - <a class="code" href="namespaceinet_1_1physicallayer.html#ab2efa56aa3bcc6b59af7ce2efdcfc9d8">k</a> : <a class="code" href="namespaceinet_1_1physicallayer.html#ab2efa56aa3bcc6b59af7ce2efdcfc9d8">k</a>;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> dNSubK = (n - iK);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordtype">int</span> i = 1;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordtype">double</span> dRes = i &gt; iK ? 1.0 : (dNSubK + i);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160; </div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordflow">for</span> (++i; i &lt;= iK; ++i) {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        dRes *= dNSubK + i;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        dRes /= i;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    }</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">return</span> dRes;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1physicallayer_1_1_dsss_oqpsk16_modulation.html#a349a931d6554e73fd732d35a3128b0e2">inet::physicallayer::DsssOqpsk16Modulation::calculateBER()</a>.</p>

</div>
</div>
<a id="a6178a1b92c07990a26b0bd8c7780103a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6178a1b92c07990a26b0bd8c7780103a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; inet::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_domain.html">Domain</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                                                      {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespaceinet_1_1math_1_1internal.html#a23ce9fd35c61eeb071cc5b2e8f4b1422">internal::print</a>(os, d, std::index_sequence_for&lt;T ...&gt;{});</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d585d7d5ec226cbe7442fd1a6cf8d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d585d7d5ec226cbe7442fd1a6cf8d74">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; inet::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, <a class="el" href="classinet_1_1math_1_1_domain.html">Domain</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    f.print(os);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7be5ed5327ae7ed5e09bac82e6c45bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be5ed5327ae7ed5e09bac82e6c45bee">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; inet::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_interval.html">Interval</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                                                                        {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <a class="code" href="namespaceinet_1_1math_1_1internal.html#af5af6aef8bfaca7c88ceddc7f83dd1e2">internal::print</a>(os, i, std::index_sequence_for&lt;T ...&gt;{});</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4758923587cbbeee7bf1b6b724674625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4758923587cbbeee7bf1b6b724674625">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; inet::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a> ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                                                                     {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <a class="code" href="namespaceinet_1_1math_1_1internal.html#a92441f8f26b51d919710f78d34a373bc">internal::print</a>(os, p, std::index_sequence_for&lt;T ...&gt;{});</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a366cb6670e46fc2d52227fdc91b03512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366cb6670e46fc2d52227fdc91b03512">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; inet::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                                                                  {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordflow">return</span> os &lt;&lt; std::get&lt;0&gt;(p);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae92c6dce154b3cc253fc0942e6b8d291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92c6dce154b3cc253fc0942e6b8d291">&#9670;&nbsp;</a></span>printUnit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::printUnit </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;{ os &lt;&lt; <span class="stringliteral">&quot;unit&quot;</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9d1a58b75e619d519a0e8722e87379d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d1a58b75e619d519a0e8722e87379d">&#9670;&nbsp;</a></span>printUnit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::printUnit </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinet_1_1_quaternion.html">Quaternion</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;{ os &lt;&lt; <span class="stringliteral">&quot;quaternion&quot;</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8293637d64b5f91846a1ec230473bb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8293637d64b5f91846a1ec230473bb76">&#9670;&nbsp;</a></span>printUnit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::printUnit </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{ os &lt;&lt; <span class="stringliteral">&quot;s&quot;</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a73ef96a2a4dbe9345f0c3aed7cbd10e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ef96a2a4dbe9345f0c3aed7cbd10e8">&#9670;&nbsp;</a></span>printUnit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::printUnit </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;{ units::output_unit&lt;typename T::unit&gt;::fn(os); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="namespaceinet_1_1math_1_1internal.html#a23ce9fd35c61eeb071cc5b2e8f4b1422">inet::math::internal::print()</a>, and <a class="el" href="classinet_1_1math_1_1_function_base.html#a3b1badb187e7b1e32e0377c2c4f35cb4">inet::math::FunctionBase&lt; R, Domain&lt; X &gt; &gt;::print()</a>.</p>

</div>
</div>
<a id="a9bd300616e9eef6a7c35c4687ed7e479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd300616e9eef6a7c35c4687ed7e479">&#9670;&nbsp;</a></span>rad2deg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::rad2deg </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a radian value to degree. </p>
<div class="fragment"><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#a83a29e899a7f7807fff9e4659a34b10a">rad</a> * 180 / <a class="code" href="_i_n_e_t_math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1_mobility_base.html#adae1cb21e9f75ab7ffbd307ac12ffa2a">inet::MobilityBase::updateDisplayStringFromMobilityState()</a>.</p>

</div>
</div>
<a id="aee34a2a42269e7ea8a7fa2e3da5debd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee34a2a42269e7ea8a7fa2e3da5debd6">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int inet::math::round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an integer that corresponds to rounded double parameter. </p>
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ceil(d - 0.5)); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1visualizer_1_1_ieee80211_visualizer_base.html#ac6c890027612e01183938f32d2cd55a6">inet::visualizer::Ieee80211VisualizerBase::getIcon()</a>, <a class="el" href="classinet_1_1power_1_1_simple_ep_energy_storage.html#aca193e7c6e00f0605f7e7043532c9ff2">inet::power::SimpleEpEnergyStorage::handleMessage()</a>, <a class="el" href="classinet_1_1_voip_stream_sender.html#a6a5356b1a9670c768e940b1f5887b7c9">inet::VoipStreamSender::initialize()</a>, <a class="el" href="classinet_1_1ospfv2_1_1_ospfv2_config_reader.html#aa1b9662a79e216a50c31487bc6ed62dd">inet::ospfv2::Ospfv2ConfigReader::loadInterfaceParameters()</a>, <a class="el" href="classinet_1_1power_1_1_simple_cc_battery.html#a5e8bc7b05fef143d3d045a85084d3b95">inet::power::SimpleCcBattery::resolveDirective()</a>, and <a class="el" href="classinet_1_1power_1_1_simple_ep_energy_storage.html#ab239ad29a8859e1583ff58087678d5aa">inet::power::SimpleEpEnergyStorage::resolveDirective()</a>.</p>

</div>
</div>
<a id="a27e7a5e30cf695dc74a2bbb5018d140e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e7a5e30cf695dc74a2bbb5018d140e">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int inet::math::sign </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the parameter is greater than zero, -1 if less than zero, 0 otherwise. </p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;{ <span class="keywordflow">return</span> (0 &lt; v) - (v &lt; 0); };</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1visualizer_1_1_line_manager.html#aa456600ef068fdb4cac7acaac3d97162">inet::visualizer::LineManager::getLineShift()</a>, <a class="el" href="classinet_1_1_mobility_base.html#ad1e39825a7b501520c4a8ecc13081e36">inet::MobilityBase::reflectIfOutside()</a>, <a class="el" href="classinet_1_1_tractor_mobility.html#aeec37340e6711259b5e6237887f72130">inet::TractorMobility::setTargetPosition()</a>, and <a class="el" href="classinet_1_1_coord.html#af7838f349cb051318438de843d57bacb">inet::Coord::sign()</a>.</p>

</div>
</div>
<a id="ab19aa6753450bccc6525bdf40f460002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19aa6753450bccc6525bdf40f460002">&#9670;&nbsp;</a></span>simplifyAndCall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::simplifyAndCall </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_bilinear_function.html">BilinearFunction</a>&lt; R, D &gt; *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;                                                                                                                                                           {</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    <span class="keywordflow">if</span> (f-&gt;getRLowerLower() == f-&gt;getRLowerUpper() &amp;&amp; f-&gt;getRLowerLower() == f-&gt;getRUpperLower() &amp;&amp; f-&gt;getRLowerLower() == f-&gt;getRUpperUpper()) {</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;        ConstantFunction&lt;R, D&gt; <a class="code" href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">g</a>(f-&gt;getRLowerLower());</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        callback(i, &amp;<a class="code" href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">g</a>);</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    }</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <span class="comment">// TODO simplify to one dimensional linear functions?</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        callback(i, f);</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac568375a8be419ce5041063f109b6f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac568375a8be419ce5041063f109b6f57">&#9670;&nbsp;</a></span>simplifyAndCall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::simplifyAndCall </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                                                                                                                                                    {</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    callback(i, f);</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1math_1_1_added_function.html#add197f7a47fc4419f62a77d2b512fbef">inet::math::AddedFunction&lt; R, D &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_subtracted_function.html#a55aa8ed8cb2e767af2f07a0ccc692268">inet::math::SubtractedFunction&lt; R, D &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_multiplied_function.html#a3bab1e315b18c00bb0b85868e5ebe05e">inet::math::MultipliedFunction&lt; R, D &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_combined2_d_function.html#a9496a078dd4c22088f35db7a8184ab35">inet::math::Combined2DFunction&lt; R, X, Y &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_divided_function.html#a42cd6ede4fe718c40d7458f6a441327f">inet::math::DividedFunction&lt; R, D &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_summed_function.html#a3cb154fee3272beb1bb8b608d627a97c">inet::math::SummedFunction&lt; R, D &gt;::partition()</a>, and <a class="el" href="classinet_1_1math_1_1_interpolated1_d_function.html#a5c0cd00b57a43c1c0d4c83941368fb18">inet::math::Interpolated1DFunction&lt; R, X &gt;::partition()</a>.</p>

</div>
</div>
<a id="a283aa71dc24ab4b91365590cae226c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283aa71dc24ab4b91365590cae226c09">&#9670;&nbsp;</a></span>simplifyAndCall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inet::math::simplifyAndCall </td>
          <td>(</td>
          <td class="paramtype">const typename D::I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_unilinear_function.html">UnilinearFunction</a>&lt; R, D &gt; *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const typename D::I &amp;, const <a class="el" href="classinet_1_1math_1_1_i_function.html">IFunction</a>&lt; R, D &gt; *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;                                                                                                                                                            {</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="keywordflow">if</span> (f-&gt;getRLower() == f-&gt;getRUpper()) {</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        ConstantFunction&lt;R, D&gt; <a class="code" href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">g</a>(f-&gt;getRLower());</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;        callback(i, &amp;<a class="code" href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">g</a>);</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    }</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;        callback(i, f);</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c102bc04fd5af5d170394d1651b4558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c102bc04fd5af5d170394d1651b4558">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::step </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">b</a> &lt; a ? 0.0 : 1.0; };</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="classinet_1_1ieee80211_1_1_frame_sequence_handler.html#a704a6a7789ef5b468c20cd5b4d07df07">inet::ieee80211::FrameSequenceHandler::abortFrameSequence()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_frame_sequence_context.html#ade28ce6228ced09634a089d13d70d559">inet::ieee80211::FrameSequenceContext::addStep()</a>, <a class="el" href="classinet_1_1_bonn_motion_mobility.html#a5911a96515deaca9b42f965eaaf8b0c5">inet::BonnMotionMobility::computeMaxSpeed()</a>, <a class="el" href="classinet_1_1physicallayer_1_1_dimensional_analog_model_base.html#a0e2b23d6bdcdabb681d5ae22672aa73e">inet::physicallayer::DimensionalAnalogModelBase::computeReceptionPower()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_rts_cts_fs.html#a571a9b89adc472cdc885b8d0a9e31a75">inet::ieee80211::RtsCtsFs::getHistory()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_frag_frame_ack_fs.html#ab7f965e0def35318215e8f1fc7e14d7e">inet::ieee80211::FragFrameAckFs::getHistory()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_last_frame_ack_fs.html#ab3357ac971d2b3cc5e7d9b076ddf2c6e">inet::ieee80211::LastFrameAckFs::getHistory()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_block_ack_req_block_ack_fs.html#adfcd38537992d120c2f11c9ed20c8fc4">inet::ieee80211::BlockAckReqBlockAckFs::getHistory()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_optional_fs.html#a8fbbfdd9cf50443d0a26b61bd16820b5">inet::ieee80211::OptionalFs::getStep()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_repeating_fs.html#ae7e6572e6ede3fa6dd4303a06ee0fe96">inet::ieee80211::RepeatingFs::getStep()</a>, <a class="el" href="classinet_1_1ieee80211_1_1_alternatives_fs.html#a46ebd8c4cf05f87c3e0879acd7ee49ef">inet::ieee80211::AlternativesFs::getStep()</a>, <a class="el" href="classinet_1_1math_1_1_approximated_function.html#a1225be4543be356c0f72bfcee3afe74d">inet::math::ApproximatedFunction&lt; R, D, DIMENSION, X &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_periodically_interpolated1_d_function.html#ac6773047734bf46044bc07047938cfaa">inet::math::PeriodicallyInterpolated1DFunction&lt; R, X &gt;::getValue()</a>, <a class="el" href="classinet_1_1_spatial_grid_1_1_line_segment_iterator.html#ae6a34ff2cefa3159b4f7212070908ea5">inet::SpatialGrid::LineSegmentIterator::operator++()</a>, <a class="el" href="classinet_1_1math_1_1_periodically_interpolated1_d_function.html#a66417fcb1088e408c9be7c178ff0a8fe">inet::math::PeriodicallyInterpolated1DFunction&lt; R, X &gt;::partition()</a>, <a class="el" href="classinet_1_1_coord.html#a6bd323a74023ebfb63cb576133622cdd">inet::Coord::step()</a>, and <a class="el" href="classinet_1_1ieee80211_1_1_frame_sequence_context.html#a5d64d16fd2bcad4d5cf45319aa607483">inet::ieee80211::FrameSequenceContext::~FrameSequenceContext()</a>.</p>

</div>
</div>
<a id="a285a7068f428a9c3a06527de64a7a403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285a7068f428a9c3a06527de64a7a403">&#9670;&nbsp;</a></span>stepfunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int inet::math::stepfunction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 0 if i is close to 0, 1 if i is positive and greater than epsilon, or -1 if it is negative and less than epsilon. </p>
<div class="fragment"><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;{ <span class="keywordflow">return</span> (i &gt; <a class="code" href="_i_n_e_t_math_8h.html#a002b2f4894492820fe708b1b7e7c5e70">EPSILON</a>) ? 1 : <a class="code" href="namespaceinet_1_1math.html#a838c5a6b516bfc8bfa4f582f26111f71">close</a>(i, 0) ? 0 : -1; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a03ee65a59d40315106967452251395ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ee65a59d40315106967452251395ed">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt;TS ...&gt; inet::math::tail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinet_1_1math_1_1_point.html">Point</a>&lt; <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>, TS ... &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all but the first coordinate of p. </p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                                              {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceinet_1_1math_1_1internal.html#a4d4448085c3bfc12e2dcf7ba3bc40eda">internal::tailImpl</a>(std::make_index_sequence&lt;<span class="keyword">sizeof</span>...(TS)&gt;(), p);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="namespaceinet_1_1math.html#a3a2a8bfeb663363abeb93c1b821d01f8">iterateCorners()</a>, and <a class="el" href="classinet_1_1eigrp_1_1_eigrp_device_configurator.html#a83bf053d08e41c5930ed405c6c7666c2">inet::eigrp::EigrpDeviceConfigurator::Str2Int()</a>.</p>

</div>
</div>
<a id="a1a52eda28998c86e22dd91f8d86319d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a52eda28998c86e22dd91f8d86319d0">&#9670;&nbsp;</a></span>toDouble() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::toDouble </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;{ <span class="keywordflow">return</span> v; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1af452e206195c533f4e81f319c8d0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af452e206195c533f4e81f319c8d0ce">&#9670;&nbsp;</a></span>toDouble() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::toDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceinet_1_1units_1_1values.html#af0c9343e984dbcf72296f65579414ec9">simsec</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;{ <span class="keywordflow">return</span> v.get().dbl(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afaf6fc10a9ad4e2de048198125d844d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf6fc10a9ad4e2de048198125d844d8">&#9670;&nbsp;</a></span>toDouble() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::toDouble </td>
          <td>(</td>
          <td class="paramtype">const simtime_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{ <span class="keywordflow">return</span> v.dbl(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a36bc5a49b216044a0e3eca99c9f16412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bc5a49b216044a0e3eca99c9f16412">&#9670;&nbsp;</a></span>toDouble() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::toDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceinet_1_1units_1_1values.html#afb328c5b0af960e7218e33635fff4968">T</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;{ <span class="keywordflow">return</span> v.get(); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="namespaceinet_1_1math_1_1internal.html#a8bbf04ab00d84ea9e3206ac12da33182">inet::math::internal::copyTupleElements()</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a655e73ef8ea7c95abd94814a171abe00">inet::math::UnilinearFunction&lt; R, D &gt;::getA()</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#ad2d8ca8c8959cf28a11a2c744b984eb4">inet::math::UnilinearFunction&lt; R, D &gt;::getB()</a>, <a class="el" href="classinet_1_1math_1_1_point.html#ae4e7fa585aef704da059d1c348f57321">inet::math::Point&lt; T ... &gt;::getImpl()</a>, <a class="el" href="classinet_1_1math_1_1_linear_interpolator.html#a244dcfa3895caa26b1a6a47e05e6f068">inet::math::LinearInterpolator&lt; X, Y &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_lineardb_interpolator.html#a189f547b81a0d1aa0585372d512c186a">inet::math::LineardbInterpolator&lt; X, Y &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_approximated_function.html#a1225be4543be356c0f72bfcee3afe74d">inet::math::ApproximatedFunction&lt; R, D, DIMENSION, X &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_gauss_function.html#a079220b67bf7f5a87a37675579f51a7d">inet::math::GaussFunction&lt; R, X &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_sawtooth_function.html#a0cc4cf14e570157803e424bc1e2dc5a7">inet::math::SawtoothFunction&lt; R, X &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_periodically_interpolated1_d_function.html#ac6773047734bf46044bc07047938cfaa">inet::math::PeriodicallyInterpolated1DFunction&lt; R, X &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_rasterized2_d_function.html#a486b03f5c3fbccec96363af71779c876">inet::math::Rasterized2DFunction&lt; R, X, Y &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_periodically_interpolated2_d_function.html#adc579b00fbd6a9d1797eef2c1acae13d">inet::math::PeriodicallyInterpolated2DFunction&lt; R, X, Y &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_integrated_function_3_01_r_00_01_domain_3_01_x_00_01_y_01_4_00_01_d_i_m_s_4b6d079b8ed0b5d70f4a7eb429f42394.html#aacdc49399f2eea2377ed663fd3680cd1">inet::math::IntegratedFunction&lt; R, Domain&lt; X, Y &gt;, DIMS, RI, Domain&lt; X &gt; &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_integrated_function.html#a6af974878fdf4ac4a8c6b74fee7e29d8">inet::math::IntegratedFunction&lt; R, D, DIMS, RI, DI &gt;::getValue()</a>, <a class="el" href="classinet_1_1math_1_1_interval.html#ac2f35f962eca03852d4eb9ef18c691c2">inet::math::Interval&lt; R &gt;::getVolumeImpl()</a>, <a class="el" href="classinet_1_1math_1_1_constant_function.html#acf5682b71ad4507a4e3936309783dc83">inet::math::ConstantFunction&lt; R, D &gt;::isFinite()</a>, <a class="el" href="classinet_1_1math_1_1_unilinear_function.html#a8d0f653c7128c196cce3a38b5647d8b0">inet::math::UnilinearFunction&lt; R, D &gt;::isFinite()</a>, <a class="el" href="classinet_1_1math_1_1_bilinear_function.html#aaf6bdb190de51a19f054b9aeb5f4a437">inet::math::BilinearFunction&lt; R, D &gt;::isFinite()</a>, <a class="el" href="classinet_1_1math_1_1_boxcar1_d_function.html#ade6f8e3e51d0114bc4fae5273cbe9481">inet::math::Boxcar1DFunction&lt; R, X &gt;::isFinite()</a>, <a class="el" href="classinet_1_1math_1_1_boxcar2_d_function.html#a14d3a35319c229ace6cabecc6c2d092f">inet::math::Boxcar2DFunction&lt; R, X, Y &gt;::isFinite()</a>, <a class="el" href="classinet_1_1_int128.html#a7cbd3a7e082d9b21b2f9daeaa5dd8d47">inet::Int128::operator double()</a>, <a class="el" href="classinet_1_1math_1_1_added_function.html#add197f7a47fc4419f62a77d2b512fbef">inet::math::AddedFunction&lt; R, D &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_multiplied_function.html#a3bab1e315b18c00bb0b85868e5ebe05e">inet::math::MultipliedFunction&lt; R, D &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_divided_function.html#a42cd6ede4fe718c40d7458f6a441327f">inet::math::DividedFunction&lt; R, D &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_periodically_interpolated1_d_function.html#a66417fcb1088e408c9be7c178ff0a8fe">inet::math::PeriodicallyInterpolated1DFunction&lt; R, X &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_rasterized2_d_function.html#aca8e7d535863aecd2c6a75a745b437af">inet::math::Rasterized2DFunction&lt; R, X, Y &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_periodically_interpolated2_d_function.html#ad08032e5e2fe077673a7bf309bea005c">inet::math::PeriodicallyInterpolated2DFunction&lt; R, X, Y &gt;::partition()</a>, <a class="el" href="classinet_1_1math_1_1_integrated_function_3_01_r_00_01_domain_3_01_x_00_01_y_01_4_00_01_d_i_m_s_4b6d079b8ed0b5d70f4a7eb429f42394.html#aaf9b67337a64fbc14e2d5ea1af598988">inet::math::IntegratedFunction&lt; R, Domain&lt; X, Y &gt;, DIMS, RI, Domain&lt; X &gt; &gt;::partition()</a>, and <a class="el" href="classinet_1_1math_1_1_point.html#aae472733d65f34b9e9e29c4390752ee8">inet::math::Point&lt; T ... &gt;::setImpl()</a>.</p>

</div>
</div>
<a id="a31e96c7e11d61986c9f8ca9e78733087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e96c7e11d61986c9f8ca9e78733087">&#9670;&nbsp;</a></span>wpHz2dBmWpMHz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double inet::math::wpHz2dBmWpMHz </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wpHz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a W/Hz value to dBmW/MHz. </p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;{ <span class="keywordflow">return</span> 10.0 * log10(wpHz * 1000000.0 * 1000.0); }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a39c89d882ac6a899a2891cc60d827693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c89d882ac6a899a2891cc60d827693">&#9670;&nbsp;</a></span>AddedFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a> <a class="el" href="classinet_1_1math_1_1_added_function.html">inet::math::AddedFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a357bbe2e9fd46f0a175b3bc63965e3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357bbe2e9fd46f0a175b3bc63965e3ca">&#9670;&nbsp;</a></span>ConstantFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a> <a class="el" href="classinet_1_1math_1_1_constant_function.html">inet::math::ConstantFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06c84a5ef3da8175f7fccec037ef4bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c84a5ef3da8175f7fccec037ef4bfe">&#9670;&nbsp;</a></span>DividedFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a> <a class="el" href="classinet_1_1math_1_1_divided_function.html">inet::math::DividedFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a78dea1598d22deecc88d3b61379caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a78dea1598d22deecc88d3b61379caf">&#9670;&nbsp;</a></span>IntegratedFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D , int DIMS, typename RI , typename DI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a> <a class="el" href="classinet_1_1math_1_1_integrated_function.html">inet::math::IntegratedFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a021a692ea7e1697fff11286c76ae4721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021a692ea7e1697fff11286c76ae4721">&#9670;&nbsp;</a></span>MultipliedFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a> <a class="el" href="classinet_1_1math_1_1_multiplied_function.html">inet::math::MultipliedFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9664f1b7ea21c27a4fc2ad259463a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9664f1b7ea21c27a4fc2ad259463a48">&#9670;&nbsp;</a></span>SubtractedFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_packet_drop__m_8h.html#ad4fa1dc2a221d8f0c1c417d4b993c51a">INET_API</a> <a class="el" href="classinet_1_1math_1_1_subtracted_function.html">inet::math::SubtractedFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceinet_1_1units_1_1units_html_a42b16566603bd538f97d32035852b7b5"><div class="ttname"><a href="namespaceinet_1_1units_1_1units.html#a42b16566603bd538f97d32035852b7b5">inet::units::units::T</a></div><div class="ttdeci">compose&lt; Wb, pow&lt; m, -2 &gt; &gt; T</div><div class="ttdef"><b>Definition:</b> Units.h:951</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1values_html_af0c9343e984dbcf72296f65579414ec9"><div class="ttname"><a href="namespaceinet_1_1units_1_1values.html#af0c9343e984dbcf72296f65579414ec9">inet::units::values::simsec</a></div><div class="ttdeci">value&lt; simtime_t, units::s &gt; simsec</div><div class="ttdef"><b>Definition:</b> Units.h:1236</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_a9a02e4290257e2c48006cc272bbaa240"><div class="ttname"><a href="namespaceinet_1_1math.html#a9a02e4290257e2c48006cc272bbaa240">inet::math::concat</a></div><div class="ttdeci">Point&lt; TS1 ..., TS2 ... &gt; concat(const Point&lt; TS1 ... &gt; &amp;p1, const Point&lt; TS2 ... &gt; &amp;p2)</div><div class="ttdoc">Returns a point by concatenating the coordinates of p1 and p2.</div><div class="ttdef"><b>Definition:</b> Point.h:234</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1units_html_a3bbcccd55eaf6edd8ab07f78d17c2f44"><div class="ttname"><a href="namespaceinet_1_1units_1_1units.html#a3bbcccd55eaf6edd8ab07f78d17c2f44">inet::units::units::deg</a></div><div class="ttdeci">fscale&lt; rad, rad2degScale &gt; deg</div><div class="ttdef"><b>Definition:</b> Units.h:1158</div></div>
<div class="ttc" id="anamespaceinet_1_1math_1_1internal_html_af5af6aef8bfaca7c88ceddc7f83dd1e2"><div class="ttname"><a href="namespaceinet_1_1math_1_1internal.html#af5af6aef8bfaca7c88ceddc7f83dd1e2">inet::math::internal::print</a></div><div class="ttdeci">std::ostream &amp; print(std::ostream &amp;os, const Interval&lt; T ... &gt; &amp;i, std::integer_sequence&lt; size_t, IS... &gt;)</div><div class="ttdef"><b>Definition:</b> Interval.h:202</div></div>
<div class="ttc" id="a_i_n_e_t_math_8h_html_a002b2f4894492820fe708b1b7e7c5e70"><div class="ttname"><a href="_i_n_e_t_math_8h.html#a002b2f4894492820fe708b1b7e7c5e70">EPSILON</a></div><div class="ttdeci">#define EPSILON</div><div class="ttdef"><b>Definition:</b> INETMath.h:86</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1units_html_a1b9208dd83b11d5f1769be7650d64c18"><div class="ttname"><a href="namespaceinet_1_1units_1_1units.html#a1b9208dd83b11d5f1769be7650d64c18">inet::units::units::mW</a></div><div class="ttdeci">milli&lt; W &gt;::type mW</div><div class="ttdef"><b>Definition:</b> Units.h:1080</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_a41e762654268b6ecddcb7dd91244afc7"><div class="ttname"><a href="namespaceinet_1_1math.html#a41e762654268b6ecddcb7dd91244afc7">inet::math::head</a></div><div class="ttdeci">T head(const Point&lt; T, TS ... &gt; &amp;p)</div><div class="ttdoc">Returns the first coordinate of p.</div><div class="ttdef"><b>Definition:</b> Point.h:222</div></div>
<div class="ttc" id="anamespaceinet_1_1math_1_1internal_html_a4d4448085c3bfc12e2dcf7ba3bc40eda"><div class="ttname"><a href="namespaceinet_1_1math_1_1internal.html#a4d4448085c3bfc12e2dcf7ba3bc40eda">inet::math::internal::tailImpl</a></div><div class="ttdeci">Point&lt; TS ... &gt; tailImpl(std::index_sequence&lt; NS ... &gt;, const Point&lt; T, TS ... &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> Point.h:203</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1units_html_a9a47d0bb11a9382eda09fa5496199a06"><div class="ttname"><a href="namespaceinet_1_1units_1_1units.html#a9a47d0bb11a9382eda09fa5496199a06">inet::units::units::g</a></div><div class="ttdeci">milli&lt; kg &gt;::type g</div><div class="ttdef"><b>Definition:</b> Units.h:1071</div></div>
<div class="ttc" id="anamespaceinet_1_1math_1_1internal_html_a23ce9fd35c61eeb071cc5b2e8f4b1422"><div class="ttname"><a href="namespaceinet_1_1math_1_1internal.html#a23ce9fd35c61eeb071cc5b2e8f4b1422">inet::math::internal::print</a></div><div class="ttdeci">std::ostream &amp; print(std::ostream &amp;os, const Domain&lt; T ... &gt; &amp;d, std::integer_sequence&lt; size_t, IS... &gt;)</div><div class="ttdef"><b>Definition:</b> Domain.h:34</div></div>
<div class="ttc" id="a_topology_8h_html_a956e2723d559858d08644ac99146e910"><div class="ttname"><a href="_topology_8h.html#a956e2723d559858d08644ac99146e910">INFINITY</a></div><div class="ttdeci">#define INFINITY</div><div class="ttdef"><b>Definition:</b> Topology.h:20</div></div>
<div class="ttc" id="a_i_n_e_t_math_8h_html_a953f667fb27fb68dd74a487d002b19b5"><div class="ttname"><a href="_i_n_e_t_math_8h.html#a953f667fb27fb68dd74a487d002b19b5">NaN</a></div><div class="ttdeci">#define NaN</div><div class="ttdef"><b>Definition:</b> INETMath.h:91</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_a838c5a6b516bfc8bfa4f582f26111f71"><div class="ttname"><a href="namespaceinet_1_1math.html#a838c5a6b516bfc8bfa4f582f26111f71">inet::math::close</a></div><div class="ttdeci">bool close(double one, double two)</div><div class="ttdoc">Tests whether two doubles are close enough to be declared equal.</div><div class="ttdef"><b>Definition:</b> INETMath.h:123</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1values_html_a02f32b4417da580f5e348f2c3cfb40a7"><div class="ttname"><a href="namespaceinet_1_1units_1_1values.html#a02f32b4417da580f5e348f2c3cfb40a7">inet::units::values::b</a></div><div class="ttdeci">value&lt; int64_t, units::b &gt; b</div><div class="ttdef"><b>Definition:</b> Units.h:1241</div></div>
<div class="ttc" id="anamespaceinet_1_1math_1_1internal_html_a8f1c5ab47a17ea8cc0c8bc2c25026c4e"><div class="ttname"><a href="namespaceinet_1_1math_1_1internal.html#a8f1c5ab47a17ea8cc0c8bc2c25026c4e">inet::math::internal::concatImpl</a></div><div class="ttdeci">Point&lt; TS1 ..., TS2 ... &gt; concatImpl(const Point&lt; TS1 ... &gt; &amp;p1, std::integer_sequence&lt; size_t, IS1 ... &gt;, const Point&lt; TS2 ... &gt; &amp;p2, std::integer_sequence&lt; size_t, IS2 ... &gt;)</div><div class="ttdef"><b>Definition:</b> Point.h:208</div></div>
<div class="ttc" id="anamespaceinet_1_1physicallayer_html_ab2efa56aa3bcc6b59af7ce2efdcfc9d8"><div class="ttname"><a href="namespaceinet_1_1physicallayer.html#ab2efa56aa3bcc6b59af7ce2efdcfc9d8">inet::physicallayer::k</a></div><div class="ttdeci">const double k</div><div class="ttdef"><b>Definition:</b> Qam1024Modulation.cc:14</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_a3a2a8bfeb663363abeb93c1b821d01f8"><div class="ttname"><a href="namespaceinet_1_1math.html#a3a2a8bfeb663363abeb93c1b821d01f8">inet::math::iterateCorners</a></div><div class="ttdeci">void iterateCorners(const Interval&lt; T0, TS ... &gt; &amp;i, const std::function&lt; void(const Point&lt; T0, TS ... &gt; &amp;)&gt; f)</div><div class="ttdef"><b>Definition:</b> Interval.h:191</div></div>
<div class="ttc" id="anamespaceinet_1_1math_1_1internal_html_a92441f8f26b51d919710f78d34a373bc"><div class="ttname"><a href="namespaceinet_1_1math_1_1internal.html#a92441f8f26b51d919710f78d34a373bc">inet::math::internal::print</a></div><div class="ttdeci">std::ostream &amp; print(std::ostream &amp;os, const Point&lt; T ... &gt; &amp;p, std::integer_sequence&lt; size_t, IS... &gt;)</div><div class="ttdef"><b>Definition:</b> Point.h:213</div></div>
<div class="ttc" id="anamespaceinet_1_1math_html_a03ee65a59d40315106967452251395ed"><div class="ttname"><a href="namespaceinet_1_1math.html#a03ee65a59d40315106967452251395ed">inet::math::tail</a></div><div class="ttdeci">Point&lt; TS ... &gt; tail(const Point&lt; T, TS ... &gt; &amp;p)</div><div class="ttdoc">Returns all but the first coordinate of p.</div><div class="ttdef"><b>Definition:</b> Point.h:228</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1values_html_a44d9b2566a438eba4f0f692170691276"><div class="ttname"><a href="namespaceinet_1_1units_1_1values.html#a44d9b2566a438eba4f0f692170691276">inet::units::values::m</a></div><div class="ttdeci">value&lt; double, units::m &gt; m</div><div class="ttdef"><b>Definition:</b> Units.h:1233</div></div>
<div class="ttc" id="anamespaceinet_1_1units_1_1values_html_a83a29e899a7f7807fff9e4659a34b10a"><div class="ttname"><a href="namespaceinet_1_1units_1_1values.html#a83a29e899a7f7807fff9e4659a34b10a">inet::units::values::rad</a></div><div class="ttdeci">value&lt; double, units::rad &gt; rad</div><div class="ttdef"><b>Definition:</b> Units.h:1245</div></div>
<div class="ttc" id="a_i_n_e_t_math_8h_html_ae71449b1cc6e6250b91f539153a7a0d3"><div class="ttname"><a href="_i_n_e_t_math_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></div><div class="ttdeci">#define M_PI</div><div class="ttdef"><b>Definition:</b> INETMath.h:52</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinet.html">inet</a></li><li class="navelem"><a class="el" href="namespaceinet_1_1math.html">math</a></li>
    <li class="footer">Generated on Sun Apr 10 2022 21:00:33 for INET Framework for OMNeT++/OMNEST by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
